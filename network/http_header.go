package network

import (
	"sonamusica-backend/logging"
	"net"
	"net/http"
	"strings"

	"github.com/go-chi/chi/v5/middleware"
	"github.com/google/uuid"
)

var (
	origin        = http.CanonicalHeaderKey("Origin")
	xRequestID    = http.CanonicalHeaderKey("X-Request-ID")
	xForwardedFor = http.CanonicalHeaderKey("X-Forwarded-For")

	// xDebugKey       = http.CanonicalHeaderKey("X-Debug-Key")
	// xVerboseLogFlag = http.CanonicalHeaderKey("X-Verbose-Log-Flag")
	// // xExperimentalFeatures contains list of chosen experimental features, separated by semicolon (;)
	// xExperimentalFeatures = http.CanonicalHeaderKey("X-Experimental-Features")
)

// // KeyVerboseLogFlag is used to enable verbose logging, only for that current request.
// type KeyVerboseLogFlag struct{}

// // ExperimentalFeaturesConfig is used to enable experimental feature that may be used by the endpoint, only for that current request.
// type KeyExperimentalFeaturesConfig struct{}

// const (
// 	ExpFeatures_Placeholder = "placeholder-feature"
// )

// type ExperimentalFeaturesConfig struct {
// 	Placeholder bool
// }

func GetOrigin(r *http.Request) string {
	return r.Header.Get(origin)
}

func GetRequestID(r *http.Request) string {
	reqID := middleware.GetReqID(r.Context())
	if reqID == "" {
		logging.HTTPServerLogger.Warn("no request ID generated by go-chi is found. using random generated UUID string")
		reqID = uuid.NewString()
	}
	return reqID
}

func GetIPAddress(r *http.Request) string {
	// Use proxied IP address, get the rightmost valid one (closest to the load balancer) if available
	xForwardedIps := strings.Split(r.Header.Get(xForwardedFor), ", ")
	for i := len(xForwardedIps) - 1; i >= 0; i-- {
		if net.ParseIP(xForwardedIps[i]) != nil {
			return xForwardedIps[i]
		}
	}

	host, _, _ := net.SplitHostPort(r.RemoteAddr)
	return host
}

// // VerifyDebugKey check if the provided header value matches the DebugKey (defined in config).
// // NOTE: We return tuple to differentiate between correct key, invalid key, and empty key
// func VerifyDebugKey(r *http.Request, validDebugKey string) (bool, error) {
// 	debugHeaderKey := r.Header.Get(xDebugKey)
// 	isMatched := debugHeaderKey == validDebugKey
// 	if debugHeaderKey == "" {
// 		return false, nil
// 	} else if !isMatched {
// 		return false, fmt.Errorf("debug header key '%s' is not a valid key! (found value = '%s')", xDebugKey, debugHeaderKey)
// 	}

// 	return true, nil
// }

// // GetVerboseLogFlag returns the "xVerboseLogFlag" http header.
// func GetVerboseLogFlag(r *http.Request) bool {
// 	verboseLogHeaderKey := r.Header.Get(xVerboseLogFlag)
// 	verboseLogFlag, _ := strconv.ParseBool(verboseLogHeaderKey)

// 	return verboseLogFlag
// }

// // GetExperimentalFeaturesConfig returns the "xExperimentalFeatures" http header.
// func GetExperimentalFeaturesConfig(r *http.Request) ExperimentalFeaturesConfig {
// 	expFeatsHeaderKey := r.Header.Get(xExperimentalFeatures)

// 	expFeatsMap := make(map[string]bool, 0)
// 	expFeats := strings.Split(expFeatsHeaderKey, ";")
// 	for _, expFeat := range expFeats {
// 		expFeatsMap[strings.TrimSpace(expFeat)] = true
// 	}

// 	expFeatsOption := ExperimentalFeaturesConfig{
// 		Placeholder: expFeatsMap[ExpFeatures_Placeholder],
// 	}

// 	return expFeatsOption
// }
