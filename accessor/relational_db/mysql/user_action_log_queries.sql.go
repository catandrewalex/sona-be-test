// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user_action_log_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const countUserActionLogs = `-- name: CountUserActionLogs :one
SELECT Count(*) AS total FROM user_action_log
WHERE
  date >= ? AND date <= ?
  AND (user_id = ? OR ? = false)
  AND (privilege_type = ? OR ? = false)
  AND (method = ? OR ? = false)
  AND (status_code = ? OR ? = false)
`

type CountUserActionLogsParams struct {
	StartDate              time.Time
	EndDate                time.Time
	UserID                 sql.NullInt64
	UseUserIDFilter        interface{}
	PrivilegeType          int32
	UsePrivilegeTypeFilter interface{}
	Method                 string
	UseMethodFilter        interface{}
	StatusCode             uint16
	UseStatusCodeFilter    interface{}
}

func (q *Queries) CountUserActionLogs(ctx context.Context, arg CountUserActionLogsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserActionLogs,
		arg.StartDate,
		arg.EndDate,
		arg.UserID,
		arg.UseUserIDFilter,
		arg.PrivilegeType,
		arg.UsePrivilegeTypeFilter,
		arg.Method,
		arg.UseMethodFilter,
		arg.StatusCode,
		arg.UseStatusCodeFilter,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteUserActionLogs = `-- name: DeleteUserActionLogs :execrows
DELETE FROM user_action_log
WHERE 
  date >= ? AND date <= ?
  AND (user_id = ? OR ? = false)
  AND (privilege_type = ? OR ? = false)
  AND (method = ? OR ? = false)
  AND (status_code = ? OR ? = false)
`

type DeleteUserActionLogsParams struct {
	StartDate              time.Time
	EndDate                time.Time
	UserID                 sql.NullInt64
	UseUserIDFilter        interface{}
	PrivilegeType          int32
	UsePrivilegeTypeFilter interface{}
	Method                 string
	UseMethodFilter        interface{}
	StatusCode             uint16
	UseStatusCodeFilter    interface{}
}

func (q *Queries) DeleteUserActionLogs(ctx context.Context, arg DeleteUserActionLogsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUserActionLogs,
		arg.StartDate,
		arg.EndDate,
		arg.UserID,
		arg.UseUserIDFilter,
		arg.PrivilegeType,
		arg.UsePrivilegeTypeFilter,
		arg.Method,
		arg.UseMethodFilter,
		arg.StatusCode,
		arg.UseStatusCodeFilter,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteUserActionLogsByIds = `-- name: DeleteUserActionLogsByIds :exec
DELETE FROM user_action_log
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteUserActionLogsByIds(ctx context.Context, ids []int64) error {
	query := deleteUserActionLogsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getUserActionLogById = `-- name: GetUserActionLogById :one
SELECT id, date, user_id, privilege_type, endpoint, method, status_code, request_body FROM user_action_log
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserActionLogById(ctx context.Context, id int64) (UserActionLog, error) {
	row := q.db.QueryRowContext(ctx, getUserActionLogById, id)
	var i UserActionLog
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.UserID,
		&i.PrivilegeType,
		&i.Endpoint,
		&i.Method,
		&i.StatusCode,
		&i.RequestBody,
	)
	return i, err
}

const getUserActionLogs = `-- name: GetUserActionLogs :many
SELECT user_action_log.id AS id, date, user_id, user.username AS username, user_action_log.privilege_type, endpoint, method, status_code, request_body
FROM user_action_log
  LEFT JOIN user ON user_id = user.id
WHERE
  date >= ? AND date <= ?
  AND (user_id = ? OR ? = false)
  AND (user_action_log.privilege_type = ? OR ? = false)
  AND (method = ? OR ? = false)
  AND (status_code = ? OR ? = false)
ORDER BY date DESC
LIMIT ? OFFSET ?
`

type GetUserActionLogsParams struct {
	StartDate              time.Time
	EndDate                time.Time
	UserID                 sql.NullInt64
	UseUserIDFilter        interface{}
	PrivilegeType          int32
	UsePrivilegeTypeFilter interface{}
	Method                 string
	UseMethodFilter        interface{}
	StatusCode             uint16
	UseStatusCodeFilter    interface{}
	Limit                  int32
	Offset                 int32
}

type GetUserActionLogsRow struct {
	ID            int64
	Date          time.Time
	UserID        sql.NullInt64
	Username      sql.NullString
	PrivilegeType int32
	Endpoint      string
	Method        string
	StatusCode    uint16
	RequestBody   string
}

func (q *Queries) GetUserActionLogs(ctx context.Context, arg GetUserActionLogsParams) ([]GetUserActionLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserActionLogs,
		arg.StartDate,
		arg.EndDate,
		arg.UserID,
		arg.UseUserIDFilter,
		arg.PrivilegeType,
		arg.UsePrivilegeTypeFilter,
		arg.Method,
		arg.UseMethodFilter,
		arg.StatusCode,
		arg.UseStatusCodeFilter,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserActionLogsRow
	for rows.Next() {
		var i GetUserActionLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.UserID,
			&i.Username,
			&i.PrivilegeType,
			&i.Endpoint,
			&i.Method,
			&i.StatusCode,
			&i.RequestBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActionLogsByUserId = `-- name: GetUserActionLogsByUserId :many
SELECT id, date, user_id, privilege_type, endpoint, method, status_code, request_body FROM user_action_log
WHERE user_id = ?
ORDER BY date DESC
LIMIT ? OFFSET ?
`

type GetUserActionLogsByUserIdParams struct {
	UserID sql.NullInt64
	Limit  int32
	Offset int32
}

func (q *Queries) GetUserActionLogsByUserId(ctx context.Context, arg GetUserActionLogsByUserIdParams) ([]UserActionLog, error) {
	rows, err := q.db.QueryContext(ctx, getUserActionLogsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserActionLog
	for rows.Next() {
		var i UserActionLog
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.UserID,
			&i.PrivilegeType,
			&i.Endpoint,
			&i.Method,
			&i.StatusCode,
			&i.RequestBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserActionLog = `-- name: InsertUserActionLog :execlastid
INSERT INTO user_action_log (
  date, user_id, privilege_type, endpoint, method, status_code, request_body) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
`

type InsertUserActionLogParams struct {
	Date          time.Time
	UserID        sql.NullInt64
	PrivilegeType int32
	Endpoint      string
	Method        string
	StatusCode    uint16
	RequestBody   string
}

func (q *Queries) InsertUserActionLog(ctx context.Context, arg InsertUserActionLogParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertUserActionLog,
		arg.Date,
		arg.UserID,
		arg.PrivilegeType,
		arg.Endpoint,
		arg.Method,
		arg.StatusCode,
		arg.RequestBody,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateUserActionLog = `-- name: UpdateUserActionLog :exec
UPDATE user_action_log SET date = ?, user_id = ?, privilege_type = ?, endpoint = ?, method = ?, status_code = ?, request_body = ? WHERE id = ?
`

type UpdateUserActionLogParams struct {
	Date          time.Time
	UserID        sql.NullInt64
	PrivilegeType int32
	Endpoint      string
	Method        string
	StatusCode    uint16
	RequestBody   string
	ID            int64
}

func (q *Queries) UpdateUserActionLog(ctx context.Context, arg UpdateUserActionLogParams) error {
	_, err := q.db.ExecContext(ctx, updateUserActionLog,
		arg.Date,
		arg.UserID,
		arg.PrivilegeType,
		arg.Endpoint,
		arg.Method,
		arg.StatusCode,
		arg.RequestBody,
		arg.ID,
	)
	return err
}
