// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: dashboard_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const getExpenseMonthlySummaryGroupedByInstrument = `-- name: GetExpenseMonthlySummaryGroupedByInstrument :many
SELECT instrument.id, instrument.name, CAST(sum(tp.paid_course_fee_value) AS SIGNED) AS total_paid_course_fee, CAST(sum(tp.paid_transport_fee_value) AS SIGNED) AS total_paid_transport_fee
FROM teacher_payment AS tp
    JOIN attendance ON tp.attendance_id = attendance.id
    JOIN class ON attendance.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON instrument_id = instrument.id
WHERE
    (tp.added_at >= ? AND tp.added_at <= ?)
    AND (class.teacher_id IN (/*SLICE:teacher_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY instrument.id
ORDER BY total_paid_course_fee
`

type GetExpenseMonthlySummaryGroupedByInstrumentParams struct {
	StartDate           time.Time
	EndDate             time.Time
	TeacherIds          []sql.NullInt64
	UseTeacherFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetExpenseMonthlySummaryGroupedByInstrumentRow struct {
	Instrument            Instrument
	TotalPaidCourseFee    int64
	TotalPaidTransportFee int64
}

func (q *Queries) GetExpenseMonthlySummaryGroupedByInstrument(ctx context.Context, arg GetExpenseMonthlySummaryGroupedByInstrumentParams) ([]GetExpenseMonthlySummaryGroupedByInstrumentRow, error) {
	query := getExpenseMonthlySummaryGroupedByInstrument
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.TeacherIds) > 0 {
		for _, v := range arg.TeacherIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", strings.Repeat(",?", len(arg.TeacherIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseTeacherFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpenseMonthlySummaryGroupedByInstrumentRow
	for rows.Next() {
		var i GetExpenseMonthlySummaryGroupedByInstrumentRow
		if err := rows.Scan(
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.TotalPaidCourseFee,
			&i.TotalPaidTransportFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseMonthlySummaryGroupedByTeacher = `-- name: GetExpenseMonthlySummaryGroupedByTeacher :many
SELECT teacher.id AS teacher_id, user.id AS user_id, user_detail, CAST(sum(tp.paid_course_fee_value) AS SIGNED) AS total_paid_course_fee, CAST(sum(tp.paid_transport_fee_value) AS SIGNED) AS total_paid_transport_fee
FROM teacher_payment AS tp
    JOIN attendance ON tp.attendance_id = attendance.id
    JOIN teacher ON attendance.teacher_id = teacher.id
    JOIN user ON teacher.user_id = user.id
    
    -- we need this joins just for the filtering (instrument_id)
    JOIN class ON attendance.class_id = class.id
    JOIN course ON class.course_id = course.id
WHERE
    (tp.added_at >= ? AND tp.added_at <= ?)
    AND (class.teacher_id IN (/*SLICE:teacher_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY teacher.id
ORDER BY total_paid_course_fee
`

type GetExpenseMonthlySummaryGroupedByTeacherParams struct {
	StartDate           time.Time
	EndDate             time.Time
	TeacherIds          []sql.NullInt64
	UseTeacherFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetExpenseMonthlySummaryGroupedByTeacherRow struct {
	TeacherID             int64
	UserID                int64
	UserDetail            json.RawMessage
	TotalPaidCourseFee    int64
	TotalPaidTransportFee int64
}

func (q *Queries) GetExpenseMonthlySummaryGroupedByTeacher(ctx context.Context, arg GetExpenseMonthlySummaryGroupedByTeacherParams) ([]GetExpenseMonthlySummaryGroupedByTeacherRow, error) {
	query := getExpenseMonthlySummaryGroupedByTeacher
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.TeacherIds) > 0 {
		for _, v := range arg.TeacherIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", strings.Repeat(",?", len(arg.TeacherIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseTeacherFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpenseMonthlySummaryGroupedByTeacherRow
	for rows.Next() {
		var i GetExpenseMonthlySummaryGroupedByTeacherRow
		if err := rows.Scan(
			&i.TeacherID,
			&i.UserID,
			&i.UserDetail,
			&i.TotalPaidCourseFee,
			&i.TotalPaidTransportFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseOverview = `-- name: GetExpenseOverview :many

SELECT DATE_FORMAT(tp.added_at, '%Y-%m') AS year_with_month, CAST(sum(tp.paid_course_fee_value) AS SIGNED) AS total_paid_course_fee, CAST(sum(tp.paid_transport_fee_value) AS SIGNED) AS total_paid_transport_fee
FROM teacher_payment AS tp
    -- we need this joins just for the filtering (teacher_id & instrument_id)
    JOIN attendance ON tp.attendance_id = attendance.id
    JOIN class ON attendance.class_id = class.id
    JOIN course ON class.course_id = course.id
WHERE
    (tp.added_at >= ? AND tp.added_at <= ?)
    AND (class.teacher_id IN (/*SLICE:teacher_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY year_with_month
ORDER BY year_with_month ASC
`

type GetExpenseOverviewParams struct {
	StartDate           time.Time
	EndDate             time.Time
	TeacherIds          []sql.NullInt64
	UseTeacherFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetExpenseOverviewRow struct {
	YearWithMonth         string
	TotalPaidCourseFee    int64
	TotalPaidTransportFee int64
}

// All CAST(.. AS SIGNED) in this file (around aggregations: SUM()) are to force SQLC to generate the field type as int64. Else, they will be interface{}.
// To make things even worse: as MySQL's "SUM() of INT" type is decimal(32,0), Go's 'row.Scan(&fieldName)' will read the value as string (i.e. []uint8) instead of int!
// ============================== EXPENSE ==============================
func (q *Queries) GetExpenseOverview(ctx context.Context, arg GetExpenseOverviewParams) ([]GetExpenseOverviewRow, error) {
	query := getExpenseOverview
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.TeacherIds) > 0 {
		for _, v := range arg.TeacherIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", strings.Repeat(",?", len(arg.TeacherIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:teacher_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseTeacherFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpenseOverviewRow
	for rows.Next() {
		var i GetExpenseOverviewRow
		if err := rows.Scan(&i.YearWithMonth, &i.TotalPaidCourseFee, &i.TotalPaidTransportFee); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeMonthlySummaryGroupedByInstrument = `-- name: GetIncomeMonthlySummaryGroupedByInstrument :many
SELECT instrument.id, instrument.name, CAST(sum(ep.course_fee_value) AS SIGNED) AS total_course_fee, CAST(sum(ep.transport_fee_value) AS SIGNED) AS total_transport_fee, CAST(sum(ep.penalty_fee_value) AS SIGNED) AS total_penalty_fee_value
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id
    JOIN class ON se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON instrument_id = instrument.id
WHERE
    (ep.payment_date >= ? AND ep.payment_date <= ?)
    AND (se.student_id IN (/*SLICE:student_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY instrument.id
ORDER BY total_course_fee
`

type GetIncomeMonthlySummaryGroupedByInstrumentParams struct {
	StartDate           time.Time
	EndDate             time.Time
	StudentIds          []int64
	UseStudentFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetIncomeMonthlySummaryGroupedByInstrumentRow struct {
	Instrument           Instrument
	TotalCourseFee       int64
	TotalTransportFee    int64
	TotalPenaltyFeeValue int64
}

func (q *Queries) GetIncomeMonthlySummaryGroupedByInstrument(ctx context.Context, arg GetIncomeMonthlySummaryGroupedByInstrumentParams) ([]GetIncomeMonthlySummaryGroupedByInstrumentRow, error) {
	query := getIncomeMonthlySummaryGroupedByInstrument
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.StudentIds) > 0 {
		for _, v := range arg.StudentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:student_ids*/?", strings.Repeat(",?", len(arg.StudentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:student_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseStudentFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomeMonthlySummaryGroupedByInstrumentRow
	for rows.Next() {
		var i GetIncomeMonthlySummaryGroupedByInstrumentRow
		if err := rows.Scan(
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.TotalCourseFee,
			&i.TotalTransportFee,
			&i.TotalPenaltyFeeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeMonthlySummaryGroupedByStudent = `-- name: GetIncomeMonthlySummaryGroupedByStudent :many
SELECT student.id AS student_id, user.id AS user_id, user_detail, CAST(sum(ep.course_fee_value) AS SIGNED) AS total_course_fee, CAST(sum(ep.transport_fee_value) AS SIGNED) AS total_transport_fee, CAST(sum(ep.penalty_fee_value) AS SIGNED) AS total_penalty_fee_value
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id
    JOIN student ON se.student_id = student.id
    JOIN user ON student.user_id = user.id
    
    -- we need this joins just for the filtering (student_id & instrument_id)
    JOIN class ON se.class_id = class.id
    JOIN course ON class.course_id = course.id
WHERE
    (ep.payment_date >= ? AND ep.payment_date <= ?)
    AND (se.student_id IN (/*SLICE:student_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY student.id
ORDER BY total_course_fee
`

type GetIncomeMonthlySummaryGroupedByStudentParams struct {
	StartDate           time.Time
	EndDate             time.Time
	StudentIds          []int64
	UseStudentFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetIncomeMonthlySummaryGroupedByStudentRow struct {
	StudentID            int64
	UserID               int64
	UserDetail           json.RawMessage
	TotalCourseFee       int64
	TotalTransportFee    int64
	TotalPenaltyFeeValue int64
}

func (q *Queries) GetIncomeMonthlySummaryGroupedByStudent(ctx context.Context, arg GetIncomeMonthlySummaryGroupedByStudentParams) ([]GetIncomeMonthlySummaryGroupedByStudentRow, error) {
	query := getIncomeMonthlySummaryGroupedByStudent
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.StudentIds) > 0 {
		for _, v := range arg.StudentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:student_ids*/?", strings.Repeat(",?", len(arg.StudentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:student_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseStudentFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomeMonthlySummaryGroupedByStudentRow
	for rows.Next() {
		var i GetIncomeMonthlySummaryGroupedByStudentRow
		if err := rows.Scan(
			&i.StudentID,
			&i.UserID,
			&i.UserDetail,
			&i.TotalCourseFee,
			&i.TotalTransportFee,
			&i.TotalPenaltyFeeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeOverview = `-- name: GetIncomeOverview :many
SELECT DATE_FORMAT(ep.payment_date, '%Y-%m') AS year_with_month, CAST(sum(ep.course_fee_value) AS SIGNED) AS total_course_fee, CAST(sum(ep.transport_fee_value) AS SIGNED) AS total_transport_fee, CAST(sum(ep.penalty_fee_value) AS SIGNED) AS total_penalty_fee_value
FROM enrollment_payment AS ep
    -- we need this joins just for the filtering (student_id & instrument_id)
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id
    JOIN class ON se.class_id = class.id
    JOIN course ON class.course_id = course.id
WHERE
    (ep.payment_date >= ? AND ep.payment_date <= ?)
    AND (se.student_id IN (/*SLICE:student_ids*/?) OR ? = false)
    AND (course.instrument_id IN (/*SLICE:instrument_ids*/?) OR ? = false)
GROUP BY year_with_month
ORDER BY year_with_month ASC
`

type GetIncomeOverviewParams struct {
	StartDate           time.Time
	EndDate             time.Time
	StudentIds          []int64
	UseStudentFilter    interface{}
	InstrumentIds       []int64
	UseInstrumentFilter interface{}
}

type GetIncomeOverviewRow struct {
	YearWithMonth        string
	TotalCourseFee       int64
	TotalTransportFee    int64
	TotalPenaltyFeeValue int64
}

// ============================== INCOME ==============================
func (q *Queries) GetIncomeOverview(ctx context.Context, arg GetIncomeOverviewParams) ([]GetIncomeOverviewRow, error) {
	query := getIncomeOverview
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StartDate)
	queryParams = append(queryParams, arg.EndDate)
	if len(arg.StudentIds) > 0 {
		for _, v := range arg.StudentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:student_ids*/?", strings.Repeat(",?", len(arg.StudentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:student_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseStudentFilter)
	if len(arg.InstrumentIds) > 0 {
		for _, v := range arg.InstrumentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", strings.Repeat(",?", len(arg.InstrumentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:instrument_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UseInstrumentFilter)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomeOverviewRow
	for rows.Next() {
		var i GetIncomeOverviewRow
		if err := rows.Scan(
			&i.YearWithMonth,
			&i.TotalCourseFee,
			&i.TotalTransportFee,
			&i.TotalPenaltyFeeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
