// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: payment_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const deleteEnrollmentPaymentById = `-- name: DeleteEnrollmentPaymentById :exec
DELETE FROM enrollment_payment
WHERE id = ?
`

func (q *Queries) DeleteEnrollmentPaymentById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEnrollmentPaymentById, id)
	return err
}

const deleteStudentLearningTokenById = `-- name: DeleteStudentLearningTokenById :exec
DELETE FROM student_learning_token
WHERE id = ?
`

func (q *Queries) DeleteStudentLearningTokenById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentLearningTokenById, id)
	return err
}

const deleteTeacherSalaryById = `-- name: DeleteTeacherSalaryById :exec
DELETE FROM teacher_salary
WHERE id = ?
`

func (q *Queries) DeleteTeacherSalaryById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherSalaryById, id)
	return err
}

const getEnrollmentPaymentById = `-- name: GetEnrollmentPaymentById :one
SELECT id, payment_date, balance_top_up, value, value_penalty, enrollment_id FROM enrollment_payment
WHERE id = ? LIMIT 1
`

// ============================== ENROLLMENT_PAYMENT ==============================
func (q *Queries) GetEnrollmentPaymentById(ctx context.Context, id int64) (EnrollmentPayment, error) {
	row := q.db.QueryRowContext(ctx, getEnrollmentPaymentById, id)
	var i EnrollmentPayment
	err := row.Scan(
		&i.ID,
		&i.PaymentDate,
		&i.BalanceTopUp,
		&i.Value,
		&i.ValuePenalty,
		&i.EnrollmentID,
	)
	return i, err
}

const getEnrollmentPayments = `-- name: GetEnrollmentPayments :many
SELECT ep.id AS enrollment_payment_id, payment_date, balance_top_up, value, value_penalty,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id AS class_id, class.course_id AS course_id, CONCAT_WS(' ', instrument.name, grade.name) AS course_name
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
ORDER BY ep.id
`

type GetEnrollmentPaymentsRow struct {
	EnrollmentPaymentID int64
	PaymentDate         time.Time
	BalanceTopUp        int32
	Value               int32
	ValuePenalty        int32
	StudentID           int64
	StudentUsername     string
	StudentDetail       json.RawMessage
	ClassID             int64
	CourseID            int64
	CourseName          string
}

func (q *Queries) GetEnrollmentPayments(ctx context.Context) ([]GetEnrollmentPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnrollmentPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnrollmentPaymentsRow
	for rows.Next() {
		var i GetEnrollmentPaymentsRow
		if err := rows.Scan(
			&i.EnrollmentPaymentID,
			&i.PaymentDate,
			&i.BalanceTopUp,
			&i.Value,
			&i.ValuePenalty,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.ClassID,
			&i.CourseID,
			&i.CourseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentLearningTokenById = `-- name: GetStudentLearningTokenById :one
SELECT id, quota, quota_bonus, course_fee_value, transport_fee_value, last_updated_at, enrollment_id FROM student_learning_token
WHERE id = ? LIMIT 1
`

// ============================== STUDENT_LEARNING_TOKEN ==============================
func (q *Queries) GetStudentLearningTokenById(ctx context.Context, id int64) (StudentLearningToken, error) {
	row := q.db.QueryRowContext(ctx, getStudentLearningTokenById, id)
	var i StudentLearningToken
	err := row.Scan(
		&i.ID,
		&i.Quota,
		&i.QuotaBonus,
		&i.CourseFeeValue,
		&i.TransportFeeValue,
		&i.LastUpdatedAt,
		&i.EnrollmentID,
	)
	return i, err
}

const getStudentLearningTokens = `-- name: GetStudentLearningTokens :many
SELECT slt.id AS student_learning_token_id, quota, quota_bonus, course_fee_value, transport_fee_value, last_updated_at,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id AS class_id, class.course_id AS course_id, CONCAT_WS(' ', instrument.name, grade.name) AS course_name
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
ORDER BY slt.id
`

type GetStudentLearningTokensRow struct {
	StudentLearningTokenID int64
	Quota                  int32
	QuotaBonus             int32
	CourseFeeValue         int32
	TransportFeeValue      int32
	LastUpdatedAt          time.Time
	StudentID              int64
	StudentUsername        string
	StudentDetail          json.RawMessage
	ClassID                int64
	CourseID               int64
	CourseName             string
}

func (q *Queries) GetStudentLearningTokens(ctx context.Context) ([]GetStudentLearningTokensRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentLearningTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentLearningTokensRow
	for rows.Next() {
		var i GetStudentLearningTokensRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.QuotaBonus,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.LastUpdatedAt,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.ClassID,
			&i.CourseID,
			&i.CourseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentLearningTokensByEnrollmentId = `-- name: GetStudentLearningTokensByEnrollmentId :many
SELECT id, quota, quota_bonus, course_fee_value, transport_fee_value, last_updated_at, enrollment_id FROM student_learning_token
WHERE enrollment_id = ?
`

func (q *Queries) GetStudentLearningTokensByEnrollmentId(ctx context.Context, enrollmentID int64) ([]StudentLearningToken, error) {
	rows, err := q.db.QueryContext(ctx, getStudentLearningTokensByEnrollmentId, enrollmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentLearningToken
	for rows.Next() {
		var i StudentLearningToken
		if err := rows.Scan(
			&i.ID,
			&i.Quota,
			&i.QuotaBonus,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.LastUpdatedAt,
			&i.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherSalaries = `-- name: GetTeacherSalaries :many
SELECT ts.id AS teacher_salary_id, profit_sharing_percentage, added_at,
    presence.id AS presence_id, date, used_student_token_quota, duration,
    presence.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    class.id AS class_id, course_id, CONCAT_WS(' ', instrument.name, grade.name) AS course_name,
    sa.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail
FROM teacher_salary AS ts
    JOIN presence ON presence_id = presence.id
    LEFT JOIN teacher ON presence.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN class on presence.class_id = class.id
    LEFT JOIN course ON class.course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    LEFT JOIN student_attend AS sa ON presence.id = sa.presence_id
    LEFT JOIN user AS user_student ON sa.student_id = user_student.id
ORDER BY ts.id
`

type GetTeacherSalariesRow struct {
	TeacherSalaryID         int64
	ProfitSharingPercentage float64
	AddedAt                 time.Time
	PresenceID              int64
	Date                    time.Time
	UsedStudentTokenQuota   float64
	Duration                int32
	TeacherID               sql.NullInt64
	TeacherUsername         sql.NullString
	TeacherDetail           []byte
	ClassID                 sql.NullInt64
	CourseID                sql.NullInt64
	CourseName              string
	StudentID               sql.NullInt64
	StudentUsername         sql.NullString
	StudentDetail           []byte
}

func (q *Queries) GetTeacherSalaries(ctx context.Context) ([]GetTeacherSalariesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherSalaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherSalariesRow
	for rows.Next() {
		var i GetTeacherSalariesRow
		if err := rows.Scan(
			&i.TeacherSalaryID,
			&i.ProfitSharingPercentage,
			&i.AddedAt,
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.ClassID,
			&i.CourseID,
			&i.CourseName,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherSalaryById = `-- name: GetTeacherSalaryById :one
SELECT id, presence_id, profit_sharing_percentage, added_at FROM teacher_salary
WHERE id = ? LIMIT 1
`

// ============================== TEACHER_SALARY ==============================
func (q *Queries) GetTeacherSalaryById(ctx context.Context, id int64) (TeacherSalary, error) {
	row := q.db.QueryRowContext(ctx, getTeacherSalaryById, id)
	var i TeacherSalary
	err := row.Scan(
		&i.ID,
		&i.PresenceID,
		&i.ProfitSharingPercentage,
		&i.AddedAt,
	)
	return i, err
}

const insertEnrollmentPayment = `-- name: InsertEnrollmentPayment :execlastid
INSERT INTO enrollment_payment (
    payment_date, balance_top_up, value, value_penalty, enrollment_id
) VALUES (
    ?, ?, ?, ?, ?
)
`

type InsertEnrollmentPaymentParams struct {
	PaymentDate  time.Time
	BalanceTopUp int32
	Value        int32
	ValuePenalty int32
	EnrollmentID sql.NullInt64
}

func (q *Queries) InsertEnrollmentPayment(ctx context.Context, arg InsertEnrollmentPaymentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertEnrollmentPayment,
		arg.PaymentDate,
		arg.BalanceTopUp,
		arg.Value,
		arg.ValuePenalty,
		arg.EnrollmentID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertStudentLearningToken = `-- name: InsertStudentLearningToken :execlastid
INSERT INTO student_learning_token (
    quota, quota_bonus, course_fee_value, transport_fee_value, last_updated_at, enrollment_id
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type InsertStudentLearningTokenParams struct {
	Quota             int32
	QuotaBonus        int32
	CourseFeeValue    int32
	TransportFeeValue int32
	LastUpdatedAt     time.Time
	EnrollmentID      int64
}

func (q *Queries) InsertStudentLearningToken(ctx context.Context, arg InsertStudentLearningTokenParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertStudentLearningToken,
		arg.Quota,
		arg.QuotaBonus,
		arg.CourseFeeValue,
		arg.TransportFeeValue,
		arg.LastUpdatedAt,
		arg.EnrollmentID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertTeacherSalary = `-- name: InsertTeacherSalary :execlastid
INSERT INTO teacher_salary (
    presence_id, profit_sharing_percentage, added_at
) VALUES (
    ?, ?, ?
)
`

type InsertTeacherSalaryParams struct {
	PresenceID              int64
	ProfitSharingPercentage float64
	AddedAt                 time.Time
}

func (q *Queries) InsertTeacherSalary(ctx context.Context, arg InsertTeacherSalaryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTeacherSalary, arg.PresenceID, arg.ProfitSharingPercentage, arg.AddedAt)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
