// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: payment_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const countEnrollmentPayments = `-- name: CountEnrollmentPayments :one
SELECT Count(id) AS total FROM enrollment_payment
`

func (q *Queries) CountEnrollmentPayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEnrollmentPayments)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countEnrollmentPaymentsByIds = `-- name: CountEnrollmentPaymentsByIds :one
SELECT Count(id) AS total FROM enrollment_payment
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountEnrollmentPaymentsByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countEnrollmentPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStudentLearningTokens = `-- name: CountStudentLearningTokens :one
SELECT Count(id) AS total FROM student_learning_token
`

func (q *Queries) CountStudentLearningTokens(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStudentLearningTokens)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStudentLearningTokensByIds = `-- name: CountStudentLearningTokensByIds :one
SELECT Count(id) AS total FROM student_learning_token
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountStudentLearningTokensByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countStudentLearningTokensByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeacherPayments = `-- name: CountTeacherPayments :one
SELECT Count(teacher_payment.id) AS total
FROM teacher_payment
    JOIN attendance ON attendance_id = attendance.id
WHERE
    (attendance.teacher_id = ? OR ? = false)
`

type CountTeacherPaymentsParams struct {
	TeacherID        int64
	UseTeacherFilter interface{}
}

func (q *Queries) CountTeacherPayments(ctx context.Context, arg CountTeacherPaymentsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTeacherPayments, arg.TeacherID, arg.UseTeacherFilter)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeacherPaymentsByIds = `-- name: CountTeacherPaymentsByIds :one
SELECT Count(id) AS total FROM teacher_payment
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountTeacherPaymentsByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countTeacherPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteEnrollmentPaymentById = `-- name: DeleteEnrollmentPaymentById :exec
DELETE FROM enrollment_payment
WHERE id = ?
`

func (q *Queries) DeleteEnrollmentPaymentById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEnrollmentPaymentById, id)
	return err
}

const deleteEnrollmentPaymentsByIds = `-- name: DeleteEnrollmentPaymentsByIds :exec
DELETE FROM enrollment_payment
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteEnrollmentPaymentsByIds(ctx context.Context, ids []int64) error {
	sql := deleteEnrollmentPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteStudentLearningTokenById = `-- name: DeleteStudentLearningTokenById :exec
DELETE FROM student_learning_token
WHERE id = ?
`

func (q *Queries) DeleteStudentLearningTokenById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentLearningTokenById, id)
	return err
}

const deleteStudentLearningTokensByIds = `-- name: DeleteStudentLearningTokensByIds :exec
DELETE FROM student_learning_token
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteStudentLearningTokensByIds(ctx context.Context, ids []int64) error {
	sql := deleteStudentLearningTokensByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteTeacherPaymentById = `-- name: DeleteTeacherPaymentById :exec
DELETE FROM teacher_payment
WHERE id = ?
`

func (q *Queries) DeleteTeacherPaymentById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherPaymentById, id)
	return err
}

const deleteTeacherPaymentsByIds = `-- name: DeleteTeacherPaymentsByIds :exec
DELETE FROM teacher_payment
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteTeacherPaymentsByIds(ctx context.Context, ids []int64) error {
	sql := deleteTeacherPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const editTeacherPayment = `-- name: EditTeacherPayment :exec
UPDATE teacher_payment SET paid_course_fee_value = ?, paid_transport_fee_value = ?
WHERE id = ?
`

type EditTeacherPaymentParams struct {
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	ID                    int64
}

func (q *Queries) EditTeacherPayment(ctx context.Context, arg EditTeacherPaymentParams) error {
	_, err := q.db.ExecContext(ctx, editTeacherPayment, arg.PaidCourseFeeValue, arg.PaidTransportFeeValue, arg.ID)
	return err
}

const getEarliestAvailableSLTsByStudentEnrollmentIds = `-- name: GetEarliestAvailableSLTsByStudentEnrollmentIds :many
WITH slt_min_max AS (
    -- fetch earliest SLT with quota > 0
    SELECT enrollment_id, MIN(created_at) AS createDateWithNonZeroQuota_or_maxCreateDate
    FROM student_learning_token
    WHERE quota > 0
    GROUP BY enrollment_id
    UNION
    -- combined with latest SLT, to cover case when all SLT has <= 0 quota
    SELECT enrollment_id, MAX(created_at) AS createDateWithNonZeroQuota_or_maxCreateDate
    FROM student_learning_token
    GROUP BY enrollment_id
    -- each record will be unique if all non-latest SLTs has 0 quota; OR duplicated (2 records) if there exists non-latest SLT with quota > 0
)
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, created_at, last_updated_at, slt.enrollment_id AS enrollment_id,
    se.student_id AS student_id
FROM student_learning_token AS slt
    JOIN (
        -- we have 1-2 SLT option per enrollment_id from ` + "`" + `slt_min_max` + "`" + `, pick the earliest
        SELECT enrollment_id, MIN(createDateWithNonZeroQuota_or_maxCreateDate) AS earliestCreateDateWithNonZeroQuota
        FROM slt_min_max
        GROUP BY enrollment_id
    ) AS slt_min ON (
        slt.enrollment_id = slt_min.enrollment_id
        AND created_at = earliestCreateDateWithNonZeroQuota
    )

    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
WHERE slt.enrollment_id IN (/*SLICE:student_enrollment_ids*/?)
`

type GetEarliestAvailableSLTsByStudentEnrollmentIdsRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	EnrollmentID           int64
	StudentID              int64
}

func (q *Queries) GetEarliestAvailableSLTsByStudentEnrollmentIds(ctx context.Context, studentEnrollmentIds []int64) ([]GetEarliestAvailableSLTsByStudentEnrollmentIdsRow, error) {
	sql := getEarliestAvailableSLTsByStudentEnrollmentIds
	var queryParams []interface{}
	if len(studentEnrollmentIds) > 0 {
		for _, v := range studentEnrollmentIds {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:student_enrollment_ids*/?", strings.Repeat(",?", len(studentEnrollmentIds))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:student_enrollment_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEarliestAvailableSLTsByStudentEnrollmentIdsRow
	for rows.Next() {
		var i GetEarliestAvailableSLTsByStudentEnrollmentIdsRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.EnrollmentID,
			&i.StudentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentPaymentById = `-- name: GetEnrollmentPaymentById :one
SELECT ep.id AS enrollment_payment_id, payment_date, balance_top_up, course_fee_value, transport_fee_value, penalty_fee_value, se.id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE ep.id = ? LIMIT 1
`

type GetEnrollmentPaymentByIdRow struct {
	EnrollmentPaymentID  int64
	PaymentDate          time.Time
	BalanceTopUp         int32
	CourseFeeValue       int32
	TransportFeeValue    int32
	PenaltyFeeValue      int32
	StudentEnrollmentID  int64
	StudentID            int64
	StudentUsername      string
	StudentDetail        json.RawMessage
	Class                Class
	TeacherSpecialFee    sql.NullInt32
	Course               Course
	Instrument           Instrument
	Grade                Grade
	ClassTeacherID       sql.NullInt64
	ClassTeacherUsername sql.NullString
	ClassTeacherDetail   []byte
}

// ============================== ENROLLMENT_PAYMENT ==============================
func (q *Queries) GetEnrollmentPaymentById(ctx context.Context, id int64) (GetEnrollmentPaymentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getEnrollmentPaymentById, id)
	var i GetEnrollmentPaymentByIdRow
	err := row.Scan(
		&i.EnrollmentPaymentID,
		&i.PaymentDate,
		&i.BalanceTopUp,
		&i.CourseFeeValue,
		&i.TransportFeeValue,
		&i.PenaltyFeeValue,
		&i.StudentEnrollmentID,
		&i.StudentID,
		&i.StudentUsername,
		&i.StudentDetail,
		&i.Class.ID,
		&i.Class.TransportFee,
		&i.Class.TeacherID,
		&i.Class.CourseID,
		&i.Class.IsDeactivated,
		&i.TeacherSpecialFee,
		&i.Course.ID,
		&i.Course.DefaultFee,
		&i.Course.DefaultDurationMinute,
		&i.Course.InstrumentID,
		&i.Course.GradeID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.ClassTeacherID,
		&i.ClassTeacherUsername,
		&i.ClassTeacherDetail,
	)
	return i, err
}

const getEnrollmentPayments = `-- name: GetEnrollmentPayments :many
SELECT ep.id AS enrollment_payment_id, payment_date, balance_top_up, course_fee_value, transport_fee_value, penalty_fee_value, se.id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE
    ep.payment_date >= ? AND ep.payment_date <= ?
ORDER BY ep.id
LIMIT ? OFFSET ?
`

type GetEnrollmentPaymentsParams struct {
	StartDate time.Time
	EndDate   time.Time
	Limit     int32
	Offset    int32
}

type GetEnrollmentPaymentsRow struct {
	EnrollmentPaymentID  int64
	PaymentDate          time.Time
	BalanceTopUp         int32
	CourseFeeValue       int32
	TransportFeeValue    int32
	PenaltyFeeValue      int32
	StudentEnrollmentID  int64
	StudentID            int64
	StudentUsername      string
	StudentDetail        json.RawMessage
	Class                Class
	TeacherSpecialFee    sql.NullInt32
	Course               Course
	Instrument           Instrument
	Grade                Grade
	ClassTeacherID       sql.NullInt64
	ClassTeacherUsername sql.NullString
	ClassTeacherDetail   []byte
}

func (q *Queries) GetEnrollmentPayments(ctx context.Context, arg GetEnrollmentPaymentsParams) ([]GetEnrollmentPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnrollmentPayments,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnrollmentPaymentsRow
	for rows.Next() {
		var i GetEnrollmentPaymentsRow
		if err := rows.Scan(
			&i.EnrollmentPaymentID,
			&i.PaymentDate,
			&i.BalanceTopUp,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.PenaltyFeeValue,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentPaymentsByIds = `-- name: GetEnrollmentPaymentsByIds :many
SELECT ep.id AS enrollment_payment_id, payment_date, balance_top_up, course_fee_value, transport_fee_value, penalty_fee_value, se.id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE ep.id IN (/*SLICE:ids*/?)
`

type GetEnrollmentPaymentsByIdsRow struct {
	EnrollmentPaymentID  int64
	PaymentDate          time.Time
	BalanceTopUp         int32
	CourseFeeValue       int32
	TransportFeeValue    int32
	PenaltyFeeValue      int32
	StudentEnrollmentID  int64
	StudentID            int64
	StudentUsername      string
	StudentDetail        json.RawMessage
	Class                Class
	TeacherSpecialFee    sql.NullInt32
	Course               Course
	Instrument           Instrument
	Grade                Grade
	ClassTeacherID       sql.NullInt64
	ClassTeacherUsername sql.NullString
	ClassTeacherDetail   []byte
}

func (q *Queries) GetEnrollmentPaymentsByIds(ctx context.Context, ids []int64) ([]GetEnrollmentPaymentsByIdsRow, error) {
	sql := getEnrollmentPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnrollmentPaymentsByIdsRow
	for rows.Next() {
		var i GetEnrollmentPaymentsByIdsRow
		if err := rows.Scan(
			&i.EnrollmentPaymentID,
			&i.PaymentDate,
			&i.BalanceTopUp,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.PenaltyFeeValue,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentPaymentsDescendingDate = `-- name: GetEnrollmentPaymentsDescendingDate :many
SELECT ep.id AS enrollment_payment_id, payment_date, balance_top_up, course_fee_value, transport_fee_value, penalty_fee_value, se.id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM enrollment_payment AS ep
    JOIN student_enrollment AS se ON ep.enrollment_id = se.id

    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE
    ep.payment_date >= ? AND ep.payment_date <= ?
ORDER BY ep.payment_date DESC, ep.id DESC
LIMIT ? OFFSET ?
`

type GetEnrollmentPaymentsDescendingDateParams struct {
	StartDate time.Time
	EndDate   time.Time
	Limit     int32
	Offset    int32
}

type GetEnrollmentPaymentsDescendingDateRow struct {
	EnrollmentPaymentID  int64
	PaymentDate          time.Time
	BalanceTopUp         int32
	CourseFeeValue       int32
	TransportFeeValue    int32
	PenaltyFeeValue      int32
	StudentEnrollmentID  int64
	StudentID            int64
	StudentUsername      string
	StudentDetail        json.RawMessage
	Class                Class
	TeacherSpecialFee    sql.NullInt32
	Course               Course
	Instrument           Instrument
	Grade                Grade
	ClassTeacherID       sql.NullInt64
	ClassTeacherUsername sql.NullString
	ClassTeacherDetail   []byte
}

// GetEnrollmentPaymentsDescendingDate is a copy of GetEnrollmentPayments, with additional sort by date parameter. TODO: find alternative: sqlc's dynamic query which is mature enough, so that we need to do this.
func (q *Queries) GetEnrollmentPaymentsDescendingDate(ctx context.Context, arg GetEnrollmentPaymentsDescendingDateParams) ([]GetEnrollmentPaymentsDescendingDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnrollmentPaymentsDescendingDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnrollmentPaymentsDescendingDateRow
	for rows.Next() {
		var i GetEnrollmentPaymentsDescendingDateRow
		if err := rows.Scan(
			&i.EnrollmentPaymentID,
			&i.PaymentDate,
			&i.BalanceTopUp,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.PenaltyFeeValue,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEnrollmentPaymentDateByStudentEnrollmentId = `-- name: GetLatestEnrollmentPaymentDateByStudentEnrollmentId :one
SELECT MAX(payment_date) AS last_payment_date
FROM enrollment_payment
WHERE enrollment_id = ?
GROUP BY enrollment_id LIMIT 1
`

func (q *Queries) GetLatestEnrollmentPaymentDateByStudentEnrollmentId(ctx context.Context, enrollmentID sql.NullInt64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestEnrollmentPaymentDateByStudentEnrollmentId, enrollmentID)
	var last_payment_date interface{}
	err := row.Scan(&last_payment_date)
	return last_payment_date, err
}

const getSLTByClassIdForAttendanceInfo = `-- name: GetSLTByClassIdForAttendanceInfo :many
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, created_at, last_updated_at, se.student_id AS student_id
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
WHERE se.class_id = ?
ORDER BY created_at DESC, slt.id DESC
`

type GetSLTByClassIdForAttendanceInfoRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	StudentID              int64
}

func (q *Queries) GetSLTByClassIdForAttendanceInfo(ctx context.Context, classID int64) ([]GetSLTByClassIdForAttendanceInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getSLTByClassIdForAttendanceInfo, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSLTByClassIdForAttendanceInfoRow
	for rows.Next() {
		var i GetSLTByClassIdForAttendanceInfoRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.StudentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSLTByEnrollmentIdAndCourseFeeAndTransportFee = `-- name: GetSLTByEnrollmentIdAndCourseFeeAndTransportFee :one
SELECT id, quota, course_fee_value, transport_fee_value, created_at, last_updated_at, enrollment_id FROM student_learning_token
WHERE enrollment_id = ? AND course_fee_value = ? AND transport_fee_value = ?
`

type GetSLTByEnrollmentIdAndCourseFeeAndTransportFeeParams struct {
	EnrollmentID      int64
	CourseFeeValue    int32
	TransportFeeValue int32
}

func (q *Queries) GetSLTByEnrollmentIdAndCourseFeeAndTransportFee(ctx context.Context, arg GetSLTByEnrollmentIdAndCourseFeeAndTransportFeeParams) (StudentLearningToken, error) {
	row := q.db.QueryRowContext(ctx, getSLTByEnrollmentIdAndCourseFeeAndTransportFee, arg.EnrollmentID, arg.CourseFeeValue, arg.TransportFeeValue)
	var i StudentLearningToken
	err := row.Scan(
		&i.ID,
		&i.Quota,
		&i.CourseFeeValue,
		&i.TransportFeeValue,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.EnrollmentID,
	)
	return i, err
}

const getSLTWithNegativeQuotaByEnrollmentId = `-- name: GetSLTWithNegativeQuotaByEnrollmentId :many
SELECT id, quota, course_fee_value, transport_fee_value, created_at, last_updated_at, enrollment_id FROM student_learning_token
WHERE enrollment_id = ? AND quota < 0
`

// ============================== STUDENT_LEARNING_TOKEN ==============================
func (q *Queries) GetSLTWithNegativeQuotaByEnrollmentId(ctx context.Context, enrollmentID int64) ([]StudentLearningToken, error) {
	rows, err := q.db.QueryContext(ctx, getSLTWithNegativeQuotaByEnrollmentId, enrollmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentLearningToken
	for rows.Next() {
		var i StudentLearningToken
		if err := rows.Scan(
			&i.ID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentLearningTokenById = `-- name: GetStudentLearningTokenById :one
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, slt.created_at, last_updated_at, slt.enrollment_id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE slt.id = ? LIMIT 1
`

type GetStudentLearningTokenByIdRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	StudentEnrollmentID    int64
	StudentID              int64
	StudentUsername        string
	StudentDetail          json.RawMessage
	Class                  Class
	TeacherSpecialFee      sql.NullInt32
	Course                 Course
	Instrument             Instrument
	Grade                  Grade
	ClassTeacherID         sql.NullInt64
	ClassTeacherUsername   sql.NullString
	ClassTeacherDetail     []byte
}

func (q *Queries) GetStudentLearningTokenById(ctx context.Context, id int64) (GetStudentLearningTokenByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentLearningTokenById, id)
	var i GetStudentLearningTokenByIdRow
	err := row.Scan(
		&i.StudentLearningTokenID,
		&i.Quota,
		&i.CourseFeeValue,
		&i.TransportFeeValue,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.StudentEnrollmentID,
		&i.StudentID,
		&i.StudentUsername,
		&i.StudentDetail,
		&i.Class.ID,
		&i.Class.TransportFee,
		&i.Class.TeacherID,
		&i.Class.CourseID,
		&i.Class.IsDeactivated,
		&i.TeacherSpecialFee,
		&i.Course.ID,
		&i.Course.DefaultFee,
		&i.Course.DefaultDurationMinute,
		&i.Course.InstrumentID,
		&i.Course.GradeID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.ClassTeacherID,
		&i.ClassTeacherUsername,
		&i.ClassTeacherDetail,
	)
	return i, err
}

const getStudentLearningTokens = `-- name: GetStudentLearningTokens :many
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, slt.created_at, last_updated_at, slt.enrollment_id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
ORDER BY slt.id
LIMIT ? OFFSET ?
`

type GetStudentLearningTokensParams struct {
	Limit  int32
	Offset int32
}

type GetStudentLearningTokensRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	StudentEnrollmentID    int64
	StudentID              int64
	StudentUsername        string
	StudentDetail          json.RawMessage
	Class                  Class
	TeacherSpecialFee      sql.NullInt32
	Course                 Course
	Instrument             Instrument
	Grade                  Grade
	ClassTeacherID         sql.NullInt64
	ClassTeacherUsername   sql.NullString
	ClassTeacherDetail     []byte
}

func (q *Queries) GetStudentLearningTokens(ctx context.Context, arg GetStudentLearningTokensParams) ([]GetStudentLearningTokensRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentLearningTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentLearningTokensRow
	for rows.Next() {
		var i GetStudentLearningTokensRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentLearningTokensByEnrollmentId = `-- name: GetStudentLearningTokensByEnrollmentId :many
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, slt.created_at, last_updated_at, slt.enrollment_id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE slt.enrollment_id = ?
`

type GetStudentLearningTokensByEnrollmentIdRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	StudentEnrollmentID    int64
	StudentID              int64
	StudentUsername        string
	StudentDetail          json.RawMessage
	Class                  Class
	TeacherSpecialFee      sql.NullInt32
	Course                 Course
	Instrument             Instrument
	Grade                  Grade
	ClassTeacherID         sql.NullInt64
	ClassTeacherUsername   sql.NullString
	ClassTeacherDetail     []byte
}

func (q *Queries) GetStudentLearningTokensByEnrollmentId(ctx context.Context, enrollmentID int64) ([]GetStudentLearningTokensByEnrollmentIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentLearningTokensByEnrollmentId, enrollmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentLearningTokensByEnrollmentIdRow
	for rows.Next() {
		var i GetStudentLearningTokensByEnrollmentIdRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentLearningTokensByIds = `-- name: GetStudentLearningTokensByIds :many
SELECT slt.id AS student_learning_token_id, quota, course_fee_value, transport_fee_value, slt.created_at, last_updated_at, slt.enrollment_id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail
FROM student_learning_token AS slt
    JOIN student_enrollment AS se ON slt.enrollment_id = se.id
    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON class.course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
WHERE slt.id IN (/*SLICE:ids*/?)
`

type GetStudentLearningTokensByIdsRow struct {
	StudentLearningTokenID int64
	Quota                  float64
	CourseFeeValue         int32
	TransportFeeValue      int32
	CreatedAt              time.Time
	LastUpdatedAt          time.Time
	StudentEnrollmentID    int64
	StudentID              int64
	StudentUsername        string
	StudentDetail          json.RawMessage
	Class                  Class
	TeacherSpecialFee      sql.NullInt32
	Course                 Course
	Instrument             Instrument
	Grade                  Grade
	ClassTeacherID         sql.NullInt64
	ClassTeacherUsername   sql.NullString
	ClassTeacherDetail     []byte
}

func (q *Queries) GetStudentLearningTokensByIds(ctx context.Context, ids []int64) ([]GetStudentLearningTokensByIdsRow, error) {
	sql := getStudentLearningTokensByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentLearningTokensByIdsRow
	for rows.Next() {
		var i GetStudentLearningTokensByIdsRow
		if err := rows.Scan(
			&i.StudentLearningTokenID,
			&i.Quota,
			&i.CourseFeeValue,
			&i.TransportFeeValue,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherPaymentAttendanceIdsByIds = `-- name: GetTeacherPaymentAttendanceIdsByIds :many
SELECT attendance_id AS id FROM teacher_payment
WHERE teacher_payment.id IN (/*SLICE:teacher_payment_ids*/?)
`

// ============================== TEACHER_PAYMENT ==============================
func (q *Queries) GetTeacherPaymentAttendanceIdsByIds(ctx context.Context, teacherPaymentIds []int64) ([]int64, error) {
	sql := getTeacherPaymentAttendanceIdsByIds
	var queryParams []interface{}
	if len(teacherPaymentIds) > 0 {
		for _, v := range teacherPaymentIds {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:teacher_payment_ids*/?", strings.Repeat(",?", len(teacherPaymentIds))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:teacher_payment_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherPaymentById = `-- name: GetTeacherPaymentById :one
SELECT ts.id AS teacher_payment_id, paid_course_fee_value, paid_transport_fee_value, added_at,
    attendance.id, attendance.date, attendance.used_student_token_quota, attendance.duration, attendance.note, attendance.is_paid, attendance.class_id, attendance.teacher_id, attendance.student_id, attendance.token_id,
    attendance.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    attendance.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.created_at, slt.last_updated_at, slt.enrollment_id
FROM teacher_payment AS ts
    JOIN attendance ON attendance_id = attendance.id
    LEFT JOIN teacher ON attendance.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON attendance.student_id = user_student.id

    LEFT JOIN class ON attendance.class_id = class.id
    LEFT JOIN course ON class.course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
    
    JOIN student_learning_token as slt ON attendance.token_id = slt.id
WHERE ts.id = ? LIMIT 1
`

type GetTeacherPaymentByIdRow struct {
	TeacherPaymentID      int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	AddedAt               time.Time
	Attendance            Attendance
	TeacherID             int64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             int64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	Class                 Class
	TeacherSpecialFee     sql.NullInt32
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	ClassTeacherID        sql.NullInt64
	ClassTeacherUsername  sql.NullString
	ClassTeacherDetail    []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetTeacherPaymentById(ctx context.Context, id int64) (GetTeacherPaymentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherPaymentById, id)
	var i GetTeacherPaymentByIdRow
	err := row.Scan(
		&i.TeacherPaymentID,
		&i.PaidCourseFeeValue,
		&i.PaidTransportFeeValue,
		&i.AddedAt,
		&i.Attendance.ID,
		&i.Attendance.Date,
		&i.Attendance.UsedStudentTokenQuota,
		&i.Attendance.Duration,
		&i.Attendance.Note,
		&i.Attendance.IsPaid,
		&i.Attendance.ClassID,
		&i.Attendance.TeacherID,
		&i.Attendance.StudentID,
		&i.Attendance.TokenID,
		&i.TeacherID,
		&i.TeacherUsername,
		&i.TeacherDetail,
		&i.StudentID,
		&i.StudentUsername,
		&i.StudentDetail,
		&i.Class.ID,
		&i.Class.TransportFee,
		&i.Class.TeacherID,
		&i.Class.CourseID,
		&i.Class.IsDeactivated,
		&i.TeacherSpecialFee,
		&i.Course.ID,
		&i.Course.DefaultFee,
		&i.Course.DefaultDurationMinute,
		&i.Course.InstrumentID,
		&i.Course.GradeID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.ClassTeacherID,
		&i.ClassTeacherUsername,
		&i.ClassTeacherDetail,
		&i.StudentLearningToken.ID,
		&i.StudentLearningToken.Quota,
		&i.StudentLearningToken.CourseFeeValue,
		&i.StudentLearningToken.TransportFeeValue,
		&i.StudentLearningToken.CreatedAt,
		&i.StudentLearningToken.LastUpdatedAt,
		&i.StudentLearningToken.EnrollmentID,
	)
	return i, err
}

const getTeacherPayments = `-- name: GetTeacherPayments :many
SELECT ts.id AS teacher_payment_id, paid_course_fee_value, paid_transport_fee_value, added_at,
    attendance.id, attendance.date, attendance.used_student_token_quota, attendance.duration, attendance.note, attendance.is_paid, attendance.class_id, attendance.teacher_id, attendance.student_id, attendance.token_id,
    attendance.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    attendance.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.created_at, slt.last_updated_at, slt.enrollment_id
FROM teacher_payment AS ts
    JOIN attendance ON attendance_id = attendance.id
    LEFT JOIN teacher ON attendance.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON attendance.student_id = user_student.id

    LEFT JOIN class ON attendance.class_id = class.id
    LEFT JOIN course ON class.course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
    
    JOIN student_learning_token as slt ON attendance.token_id = slt.id
WHERE
    (ts.added_at >= ? AND ts.added_at <= ?)
    AND (attendance.teacher_id = ? OR ? = false)
ORDER BY ts.id
LIMIT ? OFFSET ?
`

type GetTeacherPaymentsParams struct {
	StartDate        time.Time
	EndDate          time.Time
	TeacherID        int64
	UseTeacherFilter interface{}
	Limit            int32
	Offset           int32
}

type GetTeacherPaymentsRow struct {
	TeacherPaymentID      int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	AddedAt               time.Time
	Attendance            Attendance
	TeacherID             int64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             int64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	Class                 Class
	TeacherSpecialFee     sql.NullInt32
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	ClassTeacherID        sql.NullInt64
	ClassTeacherUsername  sql.NullString
	ClassTeacherDetail    []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetTeacherPayments(ctx context.Context, arg GetTeacherPaymentsParams) ([]GetTeacherPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherPayments,
		arg.StartDate,
		arg.EndDate,
		arg.TeacherID,
		arg.UseTeacherFilter,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherPaymentsRow
	for rows.Next() {
		var i GetTeacherPaymentsRow
		if err := rows.Scan(
			&i.TeacherPaymentID,
			&i.PaidCourseFeeValue,
			&i.PaidTransportFeeValue,
			&i.AddedAt,
			&i.Attendance.ID,
			&i.Attendance.Date,
			&i.Attendance.UsedStudentTokenQuota,
			&i.Attendance.Duration,
			&i.Attendance.Note,
			&i.Attendance.IsPaid,
			&i.Attendance.ClassID,
			&i.Attendance.TeacherID,
			&i.Attendance.StudentID,
			&i.Attendance.TokenID,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.CreatedAt,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherPaymentsByIds = `-- name: GetTeacherPaymentsByIds :many
SELECT ts.id AS teacher_payment_id, paid_course_fee_value, paid_transport_fee_value, added_at,
    attendance.id, attendance.date, attendance.used_student_token_quota, attendance.duration, attendance.note, attendance.is_paid, attendance.class_id, attendance.teacher_id, attendance.student_id, attendance.token_id,
    attendance.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    attendance.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.created_at, slt.last_updated_at, slt.enrollment_id
FROM teacher_payment AS ts
    JOIN attendance ON attendance_id = attendance.id
    LEFT JOIN teacher ON attendance.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON attendance.student_id = user_student.id

    LEFT JOIN class ON attendance.class_id = class.id
    LEFT JOIN course ON class.course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
    
    JOIN student_learning_token as slt ON attendance.token_id = slt.id
WHERE ts.id IN (/*SLICE:ids*/?)
`

type GetTeacherPaymentsByIdsRow struct {
	TeacherPaymentID      int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	AddedAt               time.Time
	Attendance            Attendance
	TeacherID             int64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             int64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	Class                 Class
	TeacherSpecialFee     sql.NullInt32
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	ClassTeacherID        sql.NullInt64
	ClassTeacherUsername  sql.NullString
	ClassTeacherDetail    []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetTeacherPaymentsByIds(ctx context.Context, ids []int64) ([]GetTeacherPaymentsByIdsRow, error) {
	sql := getTeacherPaymentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherPaymentsByIdsRow
	for rows.Next() {
		var i GetTeacherPaymentsByIdsRow
		if err := rows.Scan(
			&i.TeacherPaymentID,
			&i.PaidCourseFeeValue,
			&i.PaidTransportFeeValue,
			&i.AddedAt,
			&i.Attendance.ID,
			&i.Attendance.Date,
			&i.Attendance.UsedStudentTokenQuota,
			&i.Attendance.Duration,
			&i.Attendance.Note,
			&i.Attendance.IsPaid,
			&i.Attendance.ClassID,
			&i.Attendance.TeacherID,
			&i.Attendance.StudentID,
			&i.Attendance.TokenID,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.CreatedAt,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherPaymentsByTeacherId = `-- name: GetTeacherPaymentsByTeacherId :many
SELECT ts.id AS teacher_payment_id, paid_course_fee_value, paid_transport_fee_value, added_at,
    attendance.id, attendance.date, attendance.used_student_token_quota, attendance.duration, attendance.note, attendance.is_paid, attendance.class_id, attendance.teacher_id, attendance.student_id, attendance.token_id,
    attendance.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    attendance.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, tsf.fee AS teacher_special_fee, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    class.teacher_id AS class_teacher_id, user_class_teacher.username AS class_teacher_username, user_class_teacher.user_detail AS class_teacher_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.created_at, slt.last_updated_at, slt.enrollment_id
FROM teacher_payment AS ts
    JOIN attendance ON attendance_id = attendance.id
    LEFT JOIN teacher ON attendance.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON attendance.student_id = user_student.id

    LEFT JOIN class ON attendance.class_id = class.id
    LEFT JOIN course ON class.course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id
    
    LEFT JOIN teacher AS class_teacher ON class.teacher_id = class_teacher.id
    LEFT JOIN user AS user_class_teacher ON class_teacher.user_id = user_class_teacher.id
    LEFT JOIN teacher_special_fee AS tsf ON (class_teacher.id = tsf.teacher_id AND course.id = tsf.course_id)
    
    JOIN student_learning_token as slt ON attendance.token_id = slt.id
WHERE
    (attendance.date >= ? AND attendance.date <= ?)
    AND attendance.teacher_id = ?
ORDER BY attendance.date DESC, ts.id ASC
`

type GetTeacherPaymentsByTeacherIdParams struct {
	AttendanceStartDate time.Time
	AttendanceEndDate   time.Time
	TeacherID           int64
}

type GetTeacherPaymentsByTeacherIdRow struct {
	TeacherPaymentID      int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	AddedAt               time.Time
	Attendance            Attendance
	TeacherID             int64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             int64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	Class                 Class
	TeacherSpecialFee     sql.NullInt32
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	ClassTeacherID        sql.NullInt64
	ClassTeacherUsername  sql.NullString
	ClassTeacherDetail    []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetTeacherPaymentsByTeacherId(ctx context.Context, arg GetTeacherPaymentsByTeacherIdParams) ([]GetTeacherPaymentsByTeacherIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherPaymentsByTeacherId, arg.AttendanceStartDate, arg.AttendanceEndDate, arg.TeacherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherPaymentsByTeacherIdRow
	for rows.Next() {
		var i GetTeacherPaymentsByTeacherIdRow
		if err := rows.Scan(
			&i.TeacherPaymentID,
			&i.PaidCourseFeeValue,
			&i.PaidTransportFeeValue,
			&i.AddedAt,
			&i.Attendance.ID,
			&i.Attendance.Date,
			&i.Attendance.UsedStudentTokenQuota,
			&i.Attendance.Duration,
			&i.Attendance.Note,
			&i.Attendance.IsPaid,
			&i.Attendance.ClassID,
			&i.Attendance.TeacherID,
			&i.Attendance.StudentID,
			&i.Attendance.TokenID,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.TeacherSpecialFee,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.ClassTeacherID,
			&i.ClassTeacherUsername,
			&i.ClassTeacherDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.CreatedAt,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementSLTQuotaById = `-- name: IncrementSLTQuotaById :exec
UPDATE student_learning_token SET quota = quota + ?
WHERE id = ?
`

type IncrementSLTQuotaByIdParams struct {
	Quota float64
	ID    int64
}

func (q *Queries) IncrementSLTQuotaById(ctx context.Context, arg IncrementSLTQuotaByIdParams) error {
	_, err := q.db.ExecContext(ctx, incrementSLTQuotaById, arg.Quota, arg.ID)
	return err
}

const insertEnrollmentPayment = `-- name: InsertEnrollmentPayment :execlastid
INSERT INTO enrollment_payment (
    payment_date, balance_top_up, course_fee_value, transport_fee_value, penalty_fee_value, enrollment_id
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type InsertEnrollmentPaymentParams struct {
	PaymentDate       time.Time
	BalanceTopUp      int32
	CourseFeeValue    int32
	TransportFeeValue int32
	PenaltyFeeValue   int32
	EnrollmentID      sql.NullInt64
}

func (q *Queries) InsertEnrollmentPayment(ctx context.Context, arg InsertEnrollmentPaymentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertEnrollmentPayment,
		arg.PaymentDate,
		arg.BalanceTopUp,
		arg.CourseFeeValue,
		arg.TransportFeeValue,
		arg.PenaltyFeeValue,
		arg.EnrollmentID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertStudentLearningToken = `-- name: InsertStudentLearningToken :execlastid
INSERT INTO student_learning_token (
    quota, course_fee_value, transport_fee_value, enrollment_id
) VALUES (
    ?, ?, ?, ?
)
`

type InsertStudentLearningTokenParams struct {
	Quota             float64
	CourseFeeValue    int32
	TransportFeeValue int32
	EnrollmentID      int64
}

func (q *Queries) InsertStudentLearningToken(ctx context.Context, arg InsertStudentLearningTokenParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertStudentLearningToken,
		arg.Quota,
		arg.CourseFeeValue,
		arg.TransportFeeValue,
		arg.EnrollmentID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertTeacherPayment = `-- name: InsertTeacherPayment :execlastid
INSERT INTO teacher_payment (
    attendance_id, paid_course_fee_value, paid_transport_fee_value
) VALUES (
    ?, ?, ?
)
`

type InsertTeacherPaymentParams struct {
	AttendanceID          int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
}

func (q *Queries) InsertTeacherPayment(ctx context.Context, arg InsertTeacherPaymentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTeacherPayment, arg.AttendanceID, arg.PaidCourseFeeValue, arg.PaidTransportFeeValue)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const resetStudentLearningTokenQuotaByIds = `-- name: ResetStudentLearningTokenQuotaByIds :exec
UPDATE student_learning_token SET quota = 0
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) ResetStudentLearningTokenQuotaByIds(ctx context.Context, ids []int64) error {
	sql := resetStudentLearningTokenQuotaByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const updateEnrollmentPayment = `-- name: UpdateEnrollmentPayment :exec
UPDATE enrollment_payment SET payment_date = ?, balance_top_up = ?, course_fee_value = ?, transport_fee_value = ?, penalty_fee_value = ?
WHERE id = ?
`

type UpdateEnrollmentPaymentParams struct {
	PaymentDate       time.Time
	BalanceTopUp      int32
	CourseFeeValue    int32
	TransportFeeValue int32
	PenaltyFeeValue   int32
	ID                int64
}

func (q *Queries) UpdateEnrollmentPayment(ctx context.Context, arg UpdateEnrollmentPaymentParams) error {
	_, err := q.db.ExecContext(ctx, updateEnrollmentPayment,
		arg.PaymentDate,
		arg.BalanceTopUp,
		arg.CourseFeeValue,
		arg.TransportFeeValue,
		arg.PenaltyFeeValue,
		arg.ID,
	)
	return err
}

const updateEnrollmentPaymentDateAndBalance = `-- name: UpdateEnrollmentPaymentDateAndBalance :exec
UPDATE enrollment_payment SET payment_date = ?, balance_top_up = ?
WHERE id = ?
`

type UpdateEnrollmentPaymentDateAndBalanceParams struct {
	PaymentDate  time.Time
	BalanceTopUp int32
	ID           int64
}

func (q *Queries) UpdateEnrollmentPaymentDateAndBalance(ctx context.Context, arg UpdateEnrollmentPaymentDateAndBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateEnrollmentPaymentDateAndBalance, arg.PaymentDate, arg.BalanceTopUp, arg.ID)
	return err
}

const updateStudentLearningToken = `-- name: UpdateStudentLearningToken :exec
UPDATE student_learning_token SET quota = ?, course_fee_value = ?, transport_fee_value = ?
WHERE id = ?
`

type UpdateStudentLearningTokenParams struct {
	Quota             float64
	CourseFeeValue    int32
	TransportFeeValue int32
	ID                int64
}

func (q *Queries) UpdateStudentLearningToken(ctx context.Context, arg UpdateStudentLearningTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateStudentLearningToken,
		arg.Quota,
		arg.CourseFeeValue,
		arg.TransportFeeValue,
		arg.ID,
	)
	return err
}

const updateTeacherPayment = `-- name: UpdateTeacherPayment :exec
UPDATE teacher_payment SET attendance_id = ?, paid_course_fee_value = ?, paid_transport_fee_value = ?, added_at = ?
WHERE id = ?
`

type UpdateTeacherPaymentParams struct {
	AttendanceID          int64
	PaidCourseFeeValue    int32
	PaidTransportFeeValue int32
	AddedAt               time.Time
	ID                    int64
}

func (q *Queries) UpdateTeacherPayment(ctx context.Context, arg UpdateTeacherPaymentParams) error {
	_, err := q.db.ExecContext(ctx, updateTeacherPayment,
		arg.AttendanceID,
		arg.PaidCourseFeeValue,
		arg.PaidTransportFeeValue,
		arg.AddedAt,
		arg.ID,
	)
	return err
}
