// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: teaching_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
)

const activateClass = `-- name: ActivateClass :exec
UPDATE class SET is_deactivated = 1
WHERE id = ?
`

func (q *Queries) ActivateClass(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, activateClass, id)
	return err
}

const countClasses = `-- name: CountClasses :one
SELECT Count(id) AS total FROM class
WHERE is_deactivated IN (/*SLICE:isDeactivateds*/?)
`

func (q *Queries) CountClasses(ctx context.Context, isdeactivateds []int32) (int64, error) {
	sql := countClasses
	var queryParams []interface{}
	if len(isdeactivateds) > 0 {
		for _, v := range isdeactivateds {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:isDeactivateds*/?", strings.Repeat(",?", len(isdeactivateds))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:isDeactivateds*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countClassesByIds = `-- name: CountClassesByIds :one
SELECT Count(id) AS total FROM class
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountClassesByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countClassesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countCourses = `-- name: CountCourses :one
SELECT Count(id) AS total FROM course
`

func (q *Queries) CountCourses(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCourses)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countCoursesByIds = `-- name: CountCoursesByIds :one
SELECT Count(id) AS total FROM course
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountCoursesByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countCoursesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countGrades = `-- name: CountGrades :one
SELECT Count(*) AS total FROM grade
`

func (q *Queries) CountGrades(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGrades)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countGradesByIds = `-- name: CountGradesByIds :one
SELECT Count(id) AS total FROM grade
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountGradesByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countGradesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countInstruments = `-- name: CountInstruments :one
SELECT Count(id) AS total FROM instrument
`

func (q *Queries) CountInstruments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInstruments)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countInstrumentsByIds = `-- name: CountInstrumentsByIds :one
SELECT Count(id) AS total FROM instrument
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountInstrumentsByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countInstrumentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStudentEnrollments = `-- name: CountStudentEnrollments :one
SELECT COUNT(id) FROM student_enrollment
WHERE is_deleted = 0
`

func (q *Queries) CountStudentEnrollments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStudentEnrollments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStudents = `-- name: CountStudents :one
SELECT Count(id) AS total FROM student
`

func (q *Queries) CountStudents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStudents)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStudentsByIds = `-- name: CountStudentsByIds :one
SELECT Count(id) AS total FROM student
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountStudentsByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countStudentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeacherSpecialFees = `-- name: CountTeacherSpecialFees :one
SELECT Count(id) AS total FROM teacher_special_fee
`

func (q *Queries) CountTeacherSpecialFees(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTeacherSpecialFees)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeacherSpecialFeesByIds = `-- name: CountTeacherSpecialFeesByIds :one
SELECT Count(id) AS total FROM teacher_special_fee
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountTeacherSpecialFeesByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countTeacherSpecialFeesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeachers = `-- name: CountTeachers :one
SELECT Count(id) AS total FROM teacher
`

func (q *Queries) CountTeachers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTeachers)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTeachersByIds = `-- name: CountTeachersByIds :one
SELECT Count(id) AS total FROM teacher
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountTeachersByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countTeachersByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deactivateClass = `-- name: DeactivateClass :exec
UPDATE class SET is_deactivated = 0
WHERE id = ?
`

func (q *Queries) DeactivateClass(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deactivateClass, id)
	return err
}

const deleteClassesByIds = `-- name: DeleteClassesByIds :exec
DELETE FROM class
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteClassesByIds(ctx context.Context, ids []int64) error {
	sql := deleteClassesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteCoursesByIds = `-- name: DeleteCoursesByIds :exec
DELETE FROM course
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteCoursesByIds(ctx context.Context, ids []int64) error {
	sql := deleteCoursesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteGradesByIds = `-- name: DeleteGradesByIds :exec
DELETE FROM grade
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteGradesByIds(ctx context.Context, ids []int64) error {
	sql := deleteGradesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteInstrumentsByIds = `-- name: DeleteInstrumentsByIds :exec
DELETE FROM instrument
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteInstrumentsByIds(ctx context.Context, ids []int64) error {
	sql := deleteInstrumentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteStudentByUserId = `-- name: DeleteStudentByUserId :exec
DELETE FROM student
WHERE user_id = ?
`

func (q *Queries) DeleteStudentByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentByUserId, userID)
	return err
}

const deleteStudentEnrollmentByClassIds = `-- name: DeleteStudentEnrollmentByClassIds :exec
DELETE FROM student_enrollment
WHERE class_id IN (/*SLICE:classIds*/?)
`

func (q *Queries) DeleteStudentEnrollmentByClassIds(ctx context.Context, classids []int64) error {
	sql := deleteStudentEnrollmentByClassIds
	var queryParams []interface{}
	if len(classids) > 0 {
		for _, v := range classids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:classIds*/?", strings.Repeat(",?", len(classids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:classIds*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteStudentEnrollmentById = `-- name: DeleteStudentEnrollmentById :exec
DELETE FROM student_enrollment
WHERE id = ?
`

func (q *Queries) DeleteStudentEnrollmentById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentEnrollmentById, id)
	return err
}

const deleteStudentEnrollmentByStudentId = `-- name: DeleteStudentEnrollmentByStudentId :exec
DELETE FROM student_enrollment
WHERE student_id = ?
`

func (q *Queries) DeleteStudentEnrollmentByStudentId(ctx context.Context, studentID int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentEnrollmentByStudentId, studentID)
	return err
}

const deleteStudentEnrollmentsByIds = `-- name: DeleteStudentEnrollmentsByIds :exec
DELETE FROM student_enrollment
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteStudentEnrollmentsByIds(ctx context.Context, ids []int64) error {
	sql := deleteStudentEnrollmentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteStudentsByIds = `-- name: DeleteStudentsByIds :exec
DELETE FROM student
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteStudentsByIds(ctx context.Context, ids []int64) error {
	sql := deleteStudentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteTeacherByUserId = `-- name: DeleteTeacherByUserId :exec
DELETE FROM teacher
WHERE user_id = ?
`

func (q *Queries) DeleteTeacherByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherByUserId, userID)
	return err
}

const deleteTeacherSpecialFeeByCourseId = `-- name: DeleteTeacherSpecialFeeByCourseId :exec
DELETE FROM teacher_special_fee
WHERE course_id = ?
`

func (q *Queries) DeleteTeacherSpecialFeeByCourseId(ctx context.Context, courseID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherSpecialFeeByCourseId, courseID)
	return err
}

const deleteTeacherSpecialFeeById = `-- name: DeleteTeacherSpecialFeeById :exec
DELETE FROM teacher_special_fee
WHERE id = ?
`

func (q *Queries) DeleteTeacherSpecialFeeById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherSpecialFeeById, id)
	return err
}

const deleteTeacherSpecialFeeByTeacherId = `-- name: DeleteTeacherSpecialFeeByTeacherId :exec
DELETE FROM teacher_special_fee
WHERE teacher_id = ?
`

func (q *Queries) DeleteTeacherSpecialFeeByTeacherId(ctx context.Context, teacherID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacherSpecialFeeByTeacherId, teacherID)
	return err
}

const deleteTeacherSpecialFeesByIds = `-- name: DeleteTeacherSpecialFeesByIds :exec
DELETE FROM teacher_special_fee
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteTeacherSpecialFeesByIds(ctx context.Context, ids []int64) error {
	sql := deleteTeacherSpecialFeesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const deleteTeachersByIds = `-- name: DeleteTeachersByIds :exec
DELETE FROM teacher
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteTeachersByIds(ctx context.Context, ids []int64) error {
	sql := deleteTeachersByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const disableStudentEnrollment = `-- name: DisableStudentEnrollment :exec
UPDATE student_enrollment SET is_deleted = 1
WHERE id = ?
`

func (q *Queries) DisableStudentEnrollment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, disableStudentEnrollment, id)
	return err
}

const enableStudentEnrollment = `-- name: EnableStudentEnrollment :exec
UPDATE student_enrollment SET is_deleted = 0
WHERE id = ?
`

func (q *Queries) EnableStudentEnrollment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, enableStudentEnrollment, id)
	return err
}

const getClassById = `-- name: GetClassById :many
SELECT class.id AS class_id, transport_fee, class.is_deactivated, course_id, teacher_id, se.student_id AS student_id,
    user_teacher.username AS teacher_username,
    user_teacher.user_detail AS teacher_detail,
    instrument.id, instrument.name, grade.id, grade.name,
    user_student.username AS student_username,
    user_student.user_detail AS student_detail,
    course.default_fee, course.default_duration_minute
FROM class
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id

    LEFT JOIN teacher ON teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN student_enrollment AS se ON (class.id = se.class_id AND se.is_deleted=0)
    LEFT JOIN user AS user_student ON se.student_id = user_student.id
WHERE class.id = ?
`

type GetClassByIdRow struct {
	ClassID               int64
	TransportFee          int64
	IsDeactivated         int32
	CourseID              int64
	TeacherID             sql.NullInt64
	StudentID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	Instrument            Instrument
	Grade                 Grade
	StudentUsername       sql.NullString
	StudentDetail         []byte
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetClassById(ctx context.Context, id int64) ([]GetClassByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getClassById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassByIdRow
	for rows.Next() {
		var i GetClassByIdRow
		if err := rows.Scan(
			&i.ClassID,
			&i.TransportFee,
			&i.IsDeactivated,
			&i.CourseID,
			&i.TeacherID,
			&i.StudentID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClasses = `-- name: GetClasses :many
WITH class_paginated AS (
    SELECT id, transport_fee, teacher_id, course_id, is_deactivated FROM class
    WHERE class.is_deactivated IN (/*SLICE:isDeactivateds*/?)
    LIMIT ? OFFSET ?
)
SELECT class_paginated.id AS class_id, transport_fee, class_paginated.is_deactivated, course_id, teacher_id, se.student_id AS student_id,
    user_teacher.username AS teacher_username,
    user_teacher.user_detail AS teacher_detail,
    instrument.id, instrument.name, grade.id, grade.name,
    user_student.username AS student_username,
    user_student.user_detail AS student_detail,
    course.default_fee, course.default_duration_minute
FROM class_paginated
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id

    LEFT JOIN teacher ON teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN student_enrollment AS se ON (class_paginated.id = se.class_id AND se.is_deleted=0)
    LEFT JOIN user AS user_student ON se.student_id = user_student.id
ORDER BY class_paginated.id
`

type GetClassesParams struct {
	IsDeactivateds []int32
	Limit          int32
	Offset         int32
}

type GetClassesRow struct {
	ClassID               int64
	TransportFee          int64
	IsDeactivated         int32
	CourseID              int64
	TeacherID             sql.NullInt64
	StudentID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	Instrument            Instrument
	Grade                 Grade
	StudentUsername       sql.NullString
	StudentDetail         []byte
	DefaultFee            int64
	DefaultDurationMinute int32
}

// ============================== CLASS ==============================
func (q *Queries) GetClasses(ctx context.Context, arg GetClassesParams) ([]GetClassesRow, error) {
	sql := getClasses
	var queryParams []interface{}
	if len(arg.IsDeactivateds) > 0 {
		for _, v := range arg.IsDeactivateds {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:isDeactivateds*/?", strings.Repeat(",?", len(arg.IsDeactivateds))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:isDeactivateds*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassesRow
	for rows.Next() {
		var i GetClassesRow
		if err := rows.Scan(
			&i.ClassID,
			&i.TransportFee,
			&i.IsDeactivated,
			&i.CourseID,
			&i.TeacherID,
			&i.StudentID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassesByIds = `-- name: GetClassesByIds :many
SELECT class.id AS class_id, transport_fee, class.is_deactivated, course_id, teacher_id, se.student_id AS student_id,
    user_teacher.username AS teacher_username,
    user_teacher.user_detail AS teacher_detail,
    instrument.id, instrument.name, grade.id, grade.name,
    user_student.username AS student_username,
    user_student.user_detail AS student_detail,
    course.default_fee, course.default_duration_minute
FROM class
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id

    LEFT JOIN teacher ON teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN student_enrollment AS se ON (class.id = se.class_id AND se.is_deleted=0)
    LEFT JOIN user AS user_student ON se.student_id = user_student.id
WHERE class.id in (/*SLICE:ids*/?)
ORDER BY class.id
`

type GetClassesByIdsRow struct {
	ClassID               int64
	TransportFee          int64
	IsDeactivated         int32
	CourseID              int64
	TeacherID             sql.NullInt64
	StudentID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	Instrument            Instrument
	Grade                 Grade
	StudentUsername       sql.NullString
	StudentDetail         []byte
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetClassesByIds(ctx context.Context, ids []int64) ([]GetClassesByIdsRow, error) {
	sql := getClassesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassesByIdsRow
	for rows.Next() {
		var i GetClassesByIdsRow
		if err := rows.Scan(
			&i.ClassID,
			&i.TransportFee,
			&i.IsDeactivated,
			&i.CourseID,
			&i.TeacherID,
			&i.StudentID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassesByStudentId = `-- name: GetClassesByStudentId :many
SELECT class.id AS class_id, transport_fee, class.is_deactivated, course_id, teacher_id,
    user_teacher.username AS teacher_username,
    user_teacher.user_detail AS teacher_detail,
    instrument.id, instrument.name, grade.id, grade.name,
    course.default_fee, course.default_duration_minute
FROM class
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id

    LEFT JOIN teacher ON teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN student_enrollment AS se ON (class.id = se.class_id AND se.is_deleted=0)
    LEFT JOIN user AS user_student ON se.student_id = user_student.id
WHERE se.student_id = ?
ORDER BY class.id
`

type GetClassesByStudentIdRow struct {
	ClassID               int64
	TransportFee          int64
	IsDeactivated         int32
	CourseID              int64
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetClassesByStudentId(ctx context.Context, studentID int64) ([]GetClassesByStudentIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getClassesByStudentId, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassesByStudentIdRow
	for rows.Next() {
		var i GetClassesByStudentIdRow
		if err := rows.Scan(
			&i.ClassID,
			&i.TransportFee,
			&i.IsDeactivated,
			&i.CourseID,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassesByTeacherId = `-- name: GetClassesByTeacherId :many
SELECT class.id AS class_id, transport_fee, class.is_deactivated, course_id, se.student_id AS student_id,
    instrument.id, instrument.name, grade.id, grade.name,
    user_student.username AS student_username,
    user_student.user_detail AS student_detail,
    course.default_fee, course.default_duration_minute
FROM class
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id

    LEFT JOIN teacher ON teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id

    LEFT JOIN student_enrollment AS se ON (class.id = se.class_id AND se.is_deleted=0)
    LEFT JOIN user AS user_student ON se.student_id = user_student.id
WHERE teacher_id = ?
ORDER BY class.id
`

type GetClassesByTeacherIdRow struct {
	ClassID               int64
	TransportFee          int64
	IsDeactivated         int32
	CourseID              int64
	StudentID             sql.NullInt64
	Instrument            Instrument
	Grade                 Grade
	StudentUsername       sql.NullString
	StudentDetail         []byte
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetClassesByTeacherId(ctx context.Context, teacherID sql.NullInt64) ([]GetClassesByTeacherIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getClassesByTeacherId, teacherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassesByTeacherIdRow
	for rows.Next() {
		var i GetClassesByTeacherIdRow
		if err := rows.Scan(
			&i.ClassID,
			&i.TransportFee,
			&i.IsDeactivated,
			&i.CourseID,
			&i.StudentID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseById = `-- name: GetCourseById :one
SELECT course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee, default_duration_minute
FROM course
    JOIN instrument ON instrument_id = instrument.id
    JOIN grade ON grade_id = grade.id
WHERE course.id = ? LIMIT 1
`

type GetCourseByIdRow struct {
	CourseID              int64
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetCourseById(ctx context.Context, id int64) (GetCourseByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseById, id)
	var i GetCourseByIdRow
	err := row.Scan(
		&i.CourseID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.DefaultFee,
		&i.DefaultDurationMinute,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :many
SELECT course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee, default_duration_minute
FROM course
    JOIN instrument ON instrument_id = instrument.id
    JOIN grade ON grade_id = grade.id
ORDER BY course.id
LIMIT ? OFFSET ?
`

type GetCoursesParams struct {
	Limit  int32
	Offset int32
}

type GetCoursesRow struct {
	CourseID              int64
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

// ============================== COURSE ==============================
func (q *Queries) GetCourses(ctx context.Context, arg GetCoursesParams) ([]GetCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesRow
	for rows.Next() {
		var i GetCoursesRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesByGradeId = `-- name: GetCoursesByGradeId :many
SELECT course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee, default_duration_minute
FROM course
    JOIN instrument ON instrument_id = instrument.id
    JOIN grade ON grade_id = grade.id
WHERE grade.id = ?
ORDER BY course.id
LIMIT ? OFFSET ?
`

type GetCoursesByGradeIdParams struct {
	ID     int64
	Limit  int32
	Offset int32
}

type GetCoursesByGradeIdRow struct {
	CourseID              int64
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetCoursesByGradeId(ctx context.Context, arg GetCoursesByGradeIdParams) ([]GetCoursesByGradeIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesByGradeId, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesByGradeIdRow
	for rows.Next() {
		var i GetCoursesByGradeIdRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesByIds = `-- name: GetCoursesByIds :many
SELECT course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee, default_duration_minute
FROM course
    JOIN instrument ON instrument_id = instrument.id
    JOIN grade ON grade_id = grade.id
WHERE course.id IN (/*SLICE:ids*/?)
`

type GetCoursesByIdsRow struct {
	CourseID              int64
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetCoursesByIds(ctx context.Context, ids []int64) ([]GetCoursesByIdsRow, error) {
	sql := getCoursesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesByIdsRow
	for rows.Next() {
		var i GetCoursesByIdsRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesByInstrumentId = `-- name: GetCoursesByInstrumentId :many
SELECT course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee, default_duration_minute
FROM course
    JOIN instrument ON instrument_id = instrument.id
    JOIN grade ON grade_id = grade.id
WHERE instrument.id = ?
ORDER BY course.id
LIMIT ? OFFSET ?
`

type GetCoursesByInstrumentIdParams struct {
	ID     int64
	Limit  int32
	Offset int32
}

type GetCoursesByInstrumentIdRow struct {
	CourseID              int64
	Instrument            Instrument
	Grade                 Grade
	DefaultFee            int64
	DefaultDurationMinute int32
}

func (q *Queries) GetCoursesByInstrumentId(ctx context.Context, arg GetCoursesByInstrumentIdParams) ([]GetCoursesByInstrumentIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesByInstrumentId, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesByInstrumentIdRow
	for rows.Next() {
		var i GetCoursesByInstrumentIdRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.DefaultFee,
			&i.DefaultDurationMinute,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGradeById = `-- name: GetGradeById :one
SELECT id, name FROM grade
WHERE id = ? LIMIT 1
`

// ============================== GRADE ==============================
func (q *Queries) GetGradeById(ctx context.Context, id int64) (Grade, error) {
	row := q.db.QueryRowContext(ctx, getGradeById, id)
	var i Grade
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getGrades = `-- name: GetGrades :many
SELECT id, name FROM grade
ORDER BY id
LIMIT ? OFFSET ?
`

type GetGradesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetGrades(ctx context.Context, arg GetGradesParams) ([]Grade, error) {
	rows, err := q.db.QueryContext(ctx, getGrades, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grade
	for rows.Next() {
		var i Grade
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGradesByIds = `-- name: GetGradesByIds :many
SELECT id, name FROM grade
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetGradesByIds(ctx context.Context, ids []int64) ([]Grade, error) {
	sql := getGradesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grade
	for rows.Next() {
		var i Grade
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstrumentById = `-- name: GetInstrumentById :one
SELECT id, name FROM instrument
WHERE id = ? LIMIT 1
`

// ============================== INSTRUMENT ==============================
func (q *Queries) GetInstrumentById(ctx context.Context, id int64) (Instrument, error) {
	row := q.db.QueryRowContext(ctx, getInstrumentById, id)
	var i Instrument
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getInstruments = `-- name: GetInstruments :many
SELECT id, name FROM instrument
ORDER BY id
LIMIT ? OFFSET ?
`

type GetInstrumentsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetInstruments(ctx context.Context, arg GetInstrumentsParams) ([]Instrument, error) {
	rows, err := q.db.QueryContext(ctx, getInstruments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Instrument
	for rows.Next() {
		var i Instrument
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstrumentsByIds = `-- name: GetInstrumentsByIds :many
SELECT id, name FROM instrument
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetInstrumentsByIds(ctx context.Context, ids []int64) ([]Instrument, error) {
	sql := getInstrumentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Instrument
	for rows.Next() {
		var i Instrument
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentById = `-- name: GetStudentById :one
SELECT student.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM student JOIN user ON student.user_id = user.id
WHERE student.id = ? LIMIT 1
`

type GetStudentByIdRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

// ============================== STUDENT ==============================
func (q *Queries) GetStudentById(ctx context.Context, id int64) (GetStudentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentById, id)
	var i GetStudentByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.UserDetail,
		&i.PrivilegeType,
		&i.IsDeactivated,
		&i.CreatedAt,
	)
	return i, err
}

const getStudentByUserId = `-- name: GetStudentByUserId :one
SELECT student.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM student JOIN user ON student.user_id = user.id
WHERE user_id = ? LIMIT 1
`

type GetStudentByUserIdRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetStudentByUserId(ctx context.Context, userID int64) (GetStudentByUserIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentByUserId, userID)
	var i GetStudentByUserIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.UserDetail,
		&i.PrivilegeType,
		&i.IsDeactivated,
		&i.CreatedAt,
	)
	return i, err
}

const getStudentEnrollments = `-- name: GetStudentEnrollments :many
SELECT se.id AS student_enrollment_id,
    se.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name, course.default_fee AS course_default_fee
FROM student_enrollment AS se
    JOIN user AS user_student ON se.student_id = user_student.id
    
    JOIN class on se.class_id = class.id
    JOIN course ON course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
WHERE se.is_deleted = 0
ORDER BY se.id
LIMIT ? OFFSET ?
`

type GetStudentEnrollmentsParams struct {
	Limit  int32
	Offset int32
}

type GetStudentEnrollmentsRow struct {
	StudentEnrollmentID int64
	StudentID           int64
	StudentUsername     string
	StudentDetail       json.RawMessage
	Class               Class
	Course              Course
	Instrument          Instrument
	Grade               Grade
	CourseDefaultFee    int64
}

func (q *Queries) GetStudentEnrollments(ctx context.Context, arg GetStudentEnrollmentsParams) ([]GetStudentEnrollmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentEnrollments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentEnrollmentsRow
	for rows.Next() {
		var i GetStudentEnrollmentsRow
		if err := rows.Scan(
			&i.StudentEnrollmentID,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.CourseDefaultFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentEnrollmentsByClassId = `-- name: GetStudentEnrollmentsByClassId :many
SELECT id, student_id, class_id, is_deleted FROM student_enrollment
WHERE class_id = ?
`

func (q *Queries) GetStudentEnrollmentsByClassId(ctx context.Context, classID int64) ([]StudentEnrollment, error) {
	rows, err := q.db.QueryContext(ctx, getStudentEnrollmentsByClassId, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentEnrollment
	for rows.Next() {
		var i StudentEnrollment
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.ClassID,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentEnrollmentsByIds = `-- name: GetStudentEnrollmentsByIds :many
SELECT id, student_id, class_id, is_deleted FROM student_enrollment
WHERE id IN (/*SLICE:ids*/?)
`

// ============================== STUDENT_ENROLLMENT ==============================
func (q *Queries) GetStudentEnrollmentsByIds(ctx context.Context, ids []int64) ([]StudentEnrollment, error) {
	sql := getStudentEnrollmentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentEnrollment
	for rows.Next() {
		var i StudentEnrollment
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.ClassID,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentEnrollmentsByStudentId = `-- name: GetStudentEnrollmentsByStudentId :many
SELECT id, student_id, class_id, is_deleted FROM student_enrollment
WHERE student_id = ?
`

func (q *Queries) GetStudentEnrollmentsByStudentId(ctx context.Context, studentID int64) ([]StudentEnrollment, error) {
	rows, err := q.db.QueryContext(ctx, getStudentEnrollmentsByStudentId, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentEnrollment
	for rows.Next() {
		var i StudentEnrollment
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.ClassID,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudents = `-- name: GetStudents :many
SELECT student.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM student JOIN user ON student.user_id = user.id
ORDER BY student.id
LIMIT ? OFFSET ?
`

type GetStudentsParams struct {
	Limit  int32
	Offset int32
}

type GetStudentsRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetStudents(ctx context.Context, arg GetStudentsParams) ([]GetStudentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentsRow
	for rows.Next() {
		var i GetStudentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.UserDetail,
			&i.PrivilegeType,
			&i.IsDeactivated,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsByIds = `-- name: GetStudentsByIds :many
SELECT student.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM student JOIN user ON student.user_id = user.id
WHERE student.id IN (/*SLICE:ids*/?)
`

type GetStudentsByIdsRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetStudentsByIds(ctx context.Context, ids []int64) ([]GetStudentsByIdsRow, error) {
	sql := getStudentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentsByIdsRow
	for rows.Next() {
		var i GetStudentsByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.UserDetail,
			&i.PrivilegeType,
			&i.IsDeactivated,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherById = `-- name: GetTeacherById :one
SELECT teacher.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM teacher JOIN user ON teacher.user_id = user.id
WHERE teacher.id = ? LIMIT 1
`

type GetTeacherByIdRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

// ============================== TEACHER ==============================
func (q *Queries) GetTeacherById(ctx context.Context, id int64) (GetTeacherByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherById, id)
	var i GetTeacherByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.UserDetail,
		&i.PrivilegeType,
		&i.IsDeactivated,
		&i.CreatedAt,
	)
	return i, err
}

const getTeacherByUserId = `-- name: GetTeacherByUserId :one
SELECT teacher.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM teacher JOIN user ON teacher.user_id = user.id
WHERE user_id = ? LIMIT 1
`

type GetTeacherByUserIdRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetTeacherByUserId(ctx context.Context, userID int64) (GetTeacherByUserIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherByUserId, userID)
	var i GetTeacherByUserIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.UserDetail,
		&i.PrivilegeType,
		&i.IsDeactivated,
		&i.CreatedAt,
	)
	return i, err
}

const getTeacherSpecialFeeById = `-- name: GetTeacherSpecialFeeById :one
SELECT teacher_special_fee.id AS teacher_special_fee_id, fee,
    teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee AS original_course_fee
FROM teacher_special_fee
    JOIN teacher ON teacher_id = teacher.id
    JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    JOIN course on course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
WHERE teacher_special_fee.id = ? LIMIT 1
`

type GetTeacherSpecialFeeByIdRow struct {
	TeacherSpecialFeeID int64
	Fee                 int64
	TeacherID           int64
	TeacherUsername     string
	TeacherDetail       json.RawMessage
	CourseID            int64
	Instrument          Instrument
	Grade               Grade
	OriginalCourseFee   int64
}

func (q *Queries) GetTeacherSpecialFeeById(ctx context.Context, id int64) (GetTeacherSpecialFeeByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherSpecialFeeById, id)
	var i GetTeacherSpecialFeeByIdRow
	err := row.Scan(
		&i.TeacherSpecialFeeID,
		&i.Fee,
		&i.TeacherID,
		&i.TeacherUsername,
		&i.TeacherDetail,
		&i.CourseID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.OriginalCourseFee,
	)
	return i, err
}

const getTeacherSpecialFees = `-- name: GetTeacherSpecialFees :many
SELECT teacher_special_fee.id AS teacher_special_fee_id, fee,
    teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee AS original_course_fee
FROM teacher_special_fee
    JOIN teacher ON teacher_id = teacher.id
    JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    JOIN course on course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
ORDER BY course.id
LIMIT ? OFFSET ?
`

type GetTeacherSpecialFeesParams struct {
	Limit  int32
	Offset int32
}

type GetTeacherSpecialFeesRow struct {
	TeacherSpecialFeeID int64
	Fee                 int64
	TeacherID           int64
	TeacherUsername     string
	TeacherDetail       json.RawMessage
	CourseID            int64
	Instrument          Instrument
	Grade               Grade
	OriginalCourseFee   int64
}

// ============================== TEACHER_SPECIAL_FEE ==============================
func (q *Queries) GetTeacherSpecialFees(ctx context.Context, arg GetTeacherSpecialFeesParams) ([]GetTeacherSpecialFeesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherSpecialFees, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherSpecialFeesRow
	for rows.Next() {
		var i GetTeacherSpecialFeesRow
		if err := rows.Scan(
			&i.TeacherSpecialFeeID,
			&i.Fee,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.OriginalCourseFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherSpecialFeesByIds = `-- name: GetTeacherSpecialFeesByIds :many
SELECT teacher_special_fee.id AS teacher_special_fee_id, fee,
    teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee AS original_course_fee
FROM teacher_special_fee
    JOIN teacher ON teacher_id = teacher.id
    JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    JOIN course on course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
WHERE teacher_special_fee.id IN (/*SLICE:ids*/?)
`

type GetTeacherSpecialFeesByIdsRow struct {
	TeacherSpecialFeeID int64
	Fee                 int64
	TeacherID           int64
	TeacherUsername     string
	TeacherDetail       json.RawMessage
	CourseID            int64
	Instrument          Instrument
	Grade               Grade
	OriginalCourseFee   int64
}

func (q *Queries) GetTeacherSpecialFeesByIds(ctx context.Context, ids []int64) ([]GetTeacherSpecialFeesByIdsRow, error) {
	sql := getTeacherSpecialFeesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherSpecialFeesByIdsRow
	for rows.Next() {
		var i GetTeacherSpecialFeesByIdsRow
		if err := rows.Scan(
			&i.TeacherSpecialFeeID,
			&i.Fee,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.OriginalCourseFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherSpecialFeesByTeacherId = `-- name: GetTeacherSpecialFeesByTeacherId :many
SELECT teacher_special_fee.id AS teacher_special_fee_id, fee,
    teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    course.id AS course_id, instrument.id, instrument.name, grade.id, grade.name, default_fee AS original_course_fee
FROM teacher_special_fee
    JOIN teacher ON teacher_id = teacher.id
    JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    JOIN course on course_id = course.id
    JOIN instrument ON course.instrument_id = instrument.id
    JOIN grade ON course.grade_id = grade.id
WHERE teacher_id = ?
ORDER BY course.id
`

type GetTeacherSpecialFeesByTeacherIdRow struct {
	TeacherSpecialFeeID int64
	Fee                 int64
	TeacherID           int64
	TeacherUsername     string
	TeacherDetail       json.RawMessage
	CourseID            int64
	Instrument          Instrument
	Grade               Grade
	OriginalCourseFee   int64
}

func (q *Queries) GetTeacherSpecialFeesByTeacherId(ctx context.Context, teacherID int64) ([]GetTeacherSpecialFeesByTeacherIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeacherSpecialFeesByTeacherId, teacherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeacherSpecialFeesByTeacherIdRow
	for rows.Next() {
		var i GetTeacherSpecialFeesByTeacherIdRow
		if err := rows.Scan(
			&i.TeacherSpecialFeeID,
			&i.Fee,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.CourseID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.OriginalCourseFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeacherSpecialFeesByTeacherIdAndCourseId = `-- name: GetTeacherSpecialFeesByTeacherIdAndCourseId :one
SELECT id, fee FROM teacher_special_fee
WHERE teacher_id = ? AND course_id = ? LIMIT 1
`

type GetTeacherSpecialFeesByTeacherIdAndCourseIdParams struct {
	TeacherID int64
	CourseID  int64
}

type GetTeacherSpecialFeesByTeacherIdAndCourseIdRow struct {
	ID  int64
	Fee int64
}

func (q *Queries) GetTeacherSpecialFeesByTeacherIdAndCourseId(ctx context.Context, arg GetTeacherSpecialFeesByTeacherIdAndCourseIdParams) (GetTeacherSpecialFeesByTeacherIdAndCourseIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherSpecialFeesByTeacherIdAndCourseId, arg.TeacherID, arg.CourseID)
	var i GetTeacherSpecialFeesByTeacherIdAndCourseIdRow
	err := row.Scan(&i.ID, &i.Fee)
	return i, err
}

const getTeachers = `-- name: GetTeachers :many
SELECT teacher.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM teacher JOIN user ON teacher.user_id = user.id
ORDER BY teacher.id
LIMIT ? OFFSET ?
`

type GetTeachersParams struct {
	Limit  int32
	Offset int32
}

type GetTeachersRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetTeachers(ctx context.Context, arg GetTeachersParams) ([]GetTeachersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeachers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeachersRow
	for rows.Next() {
		var i GetTeachersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.UserDetail,
			&i.PrivilegeType,
			&i.IsDeactivated,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeachersByIds = `-- name: GetTeachersByIds :many
SELECT teacher.id, user.id AS user_id, username, email, user_detail, privilege_type, is_deactivated, created_at
FROM teacher JOIN user ON teacher.user_id = user.id
WHERE teacher.id IN (/*SLICE:ids*/?)
`

type GetTeachersByIdsRow struct {
	ID            int64
	UserID        int64
	Username      string
	Email         string
	UserDetail    json.RawMessage
	PrivilegeType int32
	IsDeactivated int32
	CreatedAt     sql.NullTime
}

func (q *Queries) GetTeachersByIds(ctx context.Context, ids []int64) ([]GetTeachersByIdsRow, error) {
	sql := getTeachersByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeachersByIdsRow
	for rows.Next() {
		var i GetTeachersByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.UserDetail,
			&i.PrivilegeType,
			&i.IsDeactivated,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertClass = `-- name: InsertClass :execlastid
INSERT INTO class (
    transport_fee, teacher_id, course_id, is_deactivated
) VALUES (
    ?, ?, ?, ?
)
`

type InsertClassParams struct {
	TransportFee  int64
	TeacherID     sql.NullInt64
	CourseID      int64
	IsDeactivated int32
}

func (q *Queries) InsertClass(ctx context.Context, arg InsertClassParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertClass,
		arg.TransportFee,
		arg.TeacherID,
		arg.CourseID,
		arg.IsDeactivated,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertCourse = `-- name: InsertCourse :execlastid
INSERT INTO course (
    default_fee, default_duration_minute, instrument_id, grade_id
) VALUES (
    ?, ?, ?, ?
)
`

type InsertCourseParams struct {
	DefaultFee            int64
	DefaultDurationMinute int32
	InstrumentID          int64
	GradeID               int64
}

func (q *Queries) InsertCourse(ctx context.Context, arg InsertCourseParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertCourse,
		arg.DefaultFee,
		arg.DefaultDurationMinute,
		arg.InstrumentID,
		arg.GradeID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertGrade = `-- name: InsertGrade :execlastid
INSERT INTO grade ( name ) VALUES ( ? )
`

func (q *Queries) InsertGrade(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertGrade, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertInstrument = `-- name: InsertInstrument :execlastid
INSERT INTO instrument ( name ) VALUES ( ? )
`

func (q *Queries) InsertInstrument(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertInstrument, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertStudent = `-- name: InsertStudent :execlastid
INSERT INTO student ( user_id ) VALUES ( ? )
`

func (q *Queries) InsertStudent(ctx context.Context, userID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertStudent, userID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertStudentEnrollment = `-- name: InsertStudentEnrollment :exec
INSERT INTO student_enrollment (
    student_id, class_id
) VALUES (
    ?, ?
)
`

type InsertStudentEnrollmentParams struct {
	StudentID int64
	ClassID   int64
}

func (q *Queries) InsertStudentEnrollment(ctx context.Context, arg InsertStudentEnrollmentParams) error {
	_, err := q.db.ExecContext(ctx, insertStudentEnrollment, arg.StudentID, arg.ClassID)
	return err
}

const insertTeacher = `-- name: InsertTeacher :execlastid
INSERT INTO teacher ( user_id ) VALUES ( ? )
`

func (q *Queries) InsertTeacher(ctx context.Context, userID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTeacher, userID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertTeacherSpecialFee = `-- name: InsertTeacherSpecialFee :execlastid
INSERT INTO teacher_special_fee (
    fee, teacher_id, course_id
) VALUES (
    ?, ?, ?
)
`

type InsertTeacherSpecialFeeParams struct {
	Fee       int64
	TeacherID int64
	CourseID  int64
}

func (q *Queries) InsertTeacherSpecialFee(ctx context.Context, arg InsertTeacherSpecialFeeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTeacherSpecialFee, arg.Fee, arg.TeacherID, arg.CourseID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateClass = `-- name: UpdateClass :exec
UPDATE class SET transport_fee = ?, teacher_id = ?, is_deactivated = ?
WHERE id = ?
`

type UpdateClassParams struct {
	TransportFee  int64
	TeacherID     sql.NullInt64
	IsDeactivated int32
	ID            int64
}

func (q *Queries) UpdateClass(ctx context.Context, arg UpdateClassParams) error {
	_, err := q.db.ExecContext(ctx, updateClass,
		arg.TransportFee,
		arg.TeacherID,
		arg.IsDeactivated,
		arg.ID,
	)
	return err
}

const updateClassCourse = `-- name: UpdateClassCourse :exec
UPDATE class SET course_id = ?
WHERE id = ?
`

type UpdateClassCourseParams struct {
	CourseID int64
	ID       int64
}

func (q *Queries) UpdateClassCourse(ctx context.Context, arg UpdateClassCourseParams) error {
	_, err := q.db.ExecContext(ctx, updateClassCourse, arg.CourseID, arg.ID)
	return err
}

const updateClassInfo = `-- name: UpdateClassInfo :exec
UPDATE class SET transport_fee = ?
WHERE id = ?
`

type UpdateClassInfoParams struct {
	TransportFee int64
	ID           int64
}

func (q *Queries) UpdateClassInfo(ctx context.Context, arg UpdateClassInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateClassInfo, arg.TransportFee, arg.ID)
	return err
}

const updateClassTeacher = `-- name: UpdateClassTeacher :exec
UPDATE class SET teacher_id = ?
WHERE id = ?
`

type UpdateClassTeacherParams struct {
	TeacherID sql.NullInt64
	ID        int64
}

func (q *Queries) UpdateClassTeacher(ctx context.Context, arg UpdateClassTeacherParams) error {
	_, err := q.db.ExecContext(ctx, updateClassTeacher, arg.TeacherID, arg.ID)
	return err
}

const updateCourseGrade = `-- name: UpdateCourseGrade :exec
UPDATE course SET grade_id = ?
WHERE id = ?
`

type UpdateCourseGradeParams struct {
	GradeID int64
	ID      int64
}

func (q *Queries) UpdateCourseGrade(ctx context.Context, arg UpdateCourseGradeParams) error {
	_, err := q.db.ExecContext(ctx, updateCourseGrade, arg.GradeID, arg.ID)
	return err
}

const updateCourseInfo = `-- name: UpdateCourseInfo :exec
UPDATE course SET default_fee = ?, default_duration_minute = ?
WHERE id = ?
`

type UpdateCourseInfoParams struct {
	DefaultFee            int64
	DefaultDurationMinute int32
	ID                    int64
}

func (q *Queries) UpdateCourseInfo(ctx context.Context, arg UpdateCourseInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateCourseInfo, arg.DefaultFee, arg.DefaultDurationMinute, arg.ID)
	return err
}

const updateCourseInstrument = `-- name: UpdateCourseInstrument :exec
UPDATE course SET instrument_id = ?
WHERE id = ?
`

type UpdateCourseInstrumentParams struct {
	InstrumentID int64
	ID           int64
}

func (q *Queries) UpdateCourseInstrument(ctx context.Context, arg UpdateCourseInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, updateCourseInstrument, arg.InstrumentID, arg.ID)
	return err
}

const updateGrade = `-- name: UpdateGrade :exec
UPDATE grade SET name = ?
WHERE id = ?
`

type UpdateGradeParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateGrade(ctx context.Context, arg UpdateGradeParams) error {
	_, err := q.db.ExecContext(ctx, updateGrade, arg.Name, arg.ID)
	return err
}

const updateInstrument = `-- name: UpdateInstrument :exec
UPDATE instrument SET name = ?
WHERE id = ?
`

type UpdateInstrumentParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateInstrument(ctx context.Context, arg UpdateInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, updateInstrument, arg.Name, arg.ID)
	return err
}

const updateTeacherSpecialFee = `-- name: UpdateTeacherSpecialFee :exec
UPDATE teacher_special_fee SET fee = ?
WHERE id = ?
`

type UpdateTeacherSpecialFeeParams struct {
	Fee int64
	ID  int64
}

func (q *Queries) UpdateTeacherSpecialFee(ctx context.Context, arg UpdateTeacherSpecialFeeParams) error {
	_, err := q.db.ExecContext(ctx, updateTeacherSpecialFee, arg.Fee, arg.ID)
	return err
}
