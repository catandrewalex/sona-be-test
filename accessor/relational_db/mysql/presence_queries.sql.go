// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: presence_queries.sql

package mysql

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const countPresences = `-- name: CountPresences :one
SELECT Count(id) AS total FROM presence
WHERE date >= ? AND date <= ?
`

type CountPresencesParams struct {
	Date   time.Time
	Date_2 time.Time
}

func (q *Queries) CountPresences(ctx context.Context, arg CountPresencesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPresences, arg.Date, arg.Date_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countPresencesByClassId = `-- name: CountPresencesByClassId :one
SELECT Count(id) AS total FROM presence
WHERE class_id = ? AND date >= ? AND date <= ?
`

type CountPresencesByClassIdParams struct {
	ClassID sql.NullInt64
	Date    time.Time
	Date_2  time.Time
}

func (q *Queries) CountPresencesByClassId(ctx context.Context, arg CountPresencesByClassIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPresencesByClassId, arg.ClassID, arg.Date, arg.Date_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countPresencesByIds = `-- name: CountPresencesByIds :one
SELECT Count(id) AS total FROM presence
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) CountPresencesByIds(ctx context.Context, ids []int64) (int64, error) {
	sql := countPresencesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, sql, queryParams...)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countPresencesByStudentId = `-- name: CountPresencesByStudentId :one
SELECT Count(id) AS total FROM presence
WHERE student_id = ? AND date >= ? AND date <= ?
`

type CountPresencesByStudentIdParams struct {
	StudentID sql.NullInt64
	Date      time.Time
	Date_2    time.Time
}

func (q *Queries) CountPresencesByStudentId(ctx context.Context, arg CountPresencesByStudentIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPresencesByStudentId, arg.StudentID, arg.Date, arg.Date_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countPresencesByTeacherId = `-- name: CountPresencesByTeacherId :one
SELECT Count(id) AS total FROM presence
WHERE teacher_id = ? AND date >= ? AND date <= ?
`

type CountPresencesByTeacherIdParams struct {
	TeacherID sql.NullInt64
	Date      time.Time
	Date_2    time.Time
}

func (q *Queries) CountPresencesByTeacherId(ctx context.Context, arg CountPresencesByTeacherIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPresencesByTeacherId, arg.TeacherID, arg.Date, arg.Date_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deletePresenceById = `-- name: DeletePresenceById :exec
DELETE FROM presence
WHERE id = ?
`

func (q *Queries) DeletePresenceById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePresenceById, id)
	return err
}

const deletePresencesByIds = `-- name: DeletePresencesByIds :exec
DELETE FROM presence
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeletePresencesByIds(ctx context.Context, ids []int64) error {
	sql := deletePresencesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, sql, queryParams...)
	return err
}

const getPresenceById = `-- name: GetPresenceById :one
SELECT presence.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence
    LEFT JOIN teacher ON presence.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence.token_id = slt.id
WHERE presence.id = ? LIMIT 1
`

type GetPresenceByIdRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

// ============================== PRESENCE ==============================
func (q *Queries) GetPresenceById(ctx context.Context, id int64) (GetPresenceByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPresenceById, id)
	var i GetPresenceByIdRow
	err := row.Scan(
		&i.PresenceID,
		&i.Date,
		&i.UsedStudentTokenQuota,
		&i.Duration,
		&i.Class.ID,
		&i.Class.TransportFee,
		&i.Class.TeacherID,
		&i.Class.CourseID,
		&i.Class.IsDeactivated,
		&i.Course.ID,
		&i.Course.DefaultFee,
		&i.Course.DefaultDurationMinute,
		&i.Course.InstrumentID,
		&i.Course.GradeID,
		&i.Instrument.ID,
		&i.Instrument.Name,
		&i.Grade.ID,
		&i.Grade.Name,
		&i.TeacherID,
		&i.TeacherUsername,
		&i.TeacherDetail,
		&i.StudentID,
		&i.StudentUsername,
		&i.StudentDetail,
		&i.StudentLearningToken.ID,
		&i.StudentLearningToken.Quota,
		&i.StudentLearningToken.CourseFeeValue,
		&i.StudentLearningToken.TransportFeeValue,
		&i.StudentLearningToken.LastUpdatedAt,
		&i.StudentLearningToken.EnrollmentID,
	)
	return i, err
}

const getPresences = `-- name: GetPresences :many
SELECT presence.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence
    LEFT JOIN teacher ON presence.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence.token_id = slt.id
WHERE presence.date >= ? AND presence.date <= ?
ORDER BY class.id
LIMIT ? OFFSET ?
`

type GetPresencesParams struct {
	Date   time.Time
	Date_2 time.Time
	Limit  int32
	Offset int32
}

type GetPresencesRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetPresences(ctx context.Context, arg GetPresencesParams) ([]GetPresencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresences,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresencesRow
	for rows.Next() {
		var i GetPresencesRow
		if err := rows.Scan(
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresencesByClassId = `-- name: GetPresencesByClassId :many
WITH presence_paginated AS (
    SELECT id, date, used_student_token_quota, duration, class_id, teacher_id, student_id, token_id FROM presence
    WHERE presence.class_id = ?
    LIMIT ? OFFSET ?
)
SELECT presence_paginated.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence_paginated.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence_paginated.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence_paginated
    LEFT JOIN teacher ON presence_paginated.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence_paginated.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence_paginated.token_id = slt.id
WHERE presence.date >= ? AND presence.date <= ?
ORDER BY class.id
`

type GetPresencesByClassIdParams struct {
	ClassID sql.NullInt64
	Limit   int32
	Offset  int32
	Date    time.Time
	Date_2  time.Time
}

type GetPresencesByClassIdRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetPresencesByClassId(ctx context.Context, arg GetPresencesByClassIdParams) ([]GetPresencesByClassIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresencesByClassId,
		arg.ClassID,
		arg.Limit,
		arg.Offset,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresencesByClassIdRow
	for rows.Next() {
		var i GetPresencesByClassIdRow
		if err := rows.Scan(
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresencesByIds = `-- name: GetPresencesByIds :many
SELECT presence.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence
    LEFT JOIN teacher ON presence.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence.token_id = slt.id
WHERE presence.id IN (/*SLICE:ids*/?)
`

type GetPresencesByIdsRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetPresencesByIds(ctx context.Context, ids []int64) ([]GetPresencesByIdsRow, error) {
	sql := getPresencesByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresencesByIdsRow
	for rows.Next() {
		var i GetPresencesByIdsRow
		if err := rows.Scan(
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresencesByStudentId = `-- name: GetPresencesByStudentId :many
WITH presence_paginated AS (
    SELECT id, date, used_student_token_quota, duration, class_id, teacher_id, student_id, token_id FROM presence
    WHERE presence.student_id = ?
    LIMIT ? OFFSET ?
)
SELECT presence_paginated.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence_paginated.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence_paginated.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence_paginated
    LEFT JOIN teacher ON presence_paginated.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence_paginated.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence_paginated.token_id = slt.id
WHERE presence.date >= ? AND presence.date <= ?
ORDER BY class.id
`

type GetPresencesByStudentIdParams struct {
	StudentID sql.NullInt64
	Limit     int32
	Offset    int32
	Date      time.Time
	Date_2    time.Time
}

type GetPresencesByStudentIdRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetPresencesByStudentId(ctx context.Context, arg GetPresencesByStudentIdParams) ([]GetPresencesByStudentIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresencesByStudentId,
		arg.StudentID,
		arg.Limit,
		arg.Offset,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresencesByStudentIdRow
	for rows.Next() {
		var i GetPresencesByStudentIdRow
		if err := rows.Scan(
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresencesByTeacherId = `-- name: GetPresencesByTeacherId :many
WITH presence_paginated AS (
    SELECT id, date, used_student_token_quota, duration, class_id, teacher_id, student_id, token_id FROM presence
    WHERE presence.teacher_id = ?
    LIMIT ? OFFSET ?
)
SELECT presence_paginated.id AS presence_id, date, used_student_token_quota, duration,
    class.id, class.transport_fee, class.teacher_id, class.course_id, class.is_deactivated, course.id, course.default_fee, course.default_duration_minute, course.instrument_id, course.grade_id, instrument.id, instrument.name, grade.id, grade.name,
    presence_paginated.teacher_id AS teacher_id, user_teacher.username AS teacher_username, user_teacher.user_detail AS teacher_detail,
    presence_paginated.student_id AS student_id, user_student.username AS student_username, user_student.user_detail AS student_detail,
    slt.id, slt.quota, slt.course_fee_value, slt.transport_fee_value, slt.last_updated_at, slt.enrollment_id
FROM presence_paginated
    LEFT JOIN teacher ON presence_paginated.teacher_id = teacher.id
    LEFT JOIN user AS user_teacher ON teacher.user_id = user_teacher.id
    LEFT JOIN user AS user_student ON presence.student_id = user_student.id

    LEFT JOIN class on presence_paginated.class_id = class.id
    LEFT JOIN course ON course_id = course.id
    LEFT JOIN instrument ON course.instrument_id = instrument.id
    LEFT JOIN grade ON course.grade_id = grade.id

    JOIN student_learning_token as slt ON presence_paginated.token_id = slt.id
WHERE presence.date >= ? AND presence.date <= ?
ORDER BY class.id
`

type GetPresencesByTeacherIdParams struct {
	TeacherID sql.NullInt64
	Limit     int32
	Offset    int32
	Date      time.Time
	Date_2    time.Time
}

type GetPresencesByTeacherIdRow struct {
	PresenceID            int64
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	Class                 Class
	Course                Course
	Instrument            Instrument
	Grade                 Grade
	TeacherID             sql.NullInt64
	TeacherUsername       sql.NullString
	TeacherDetail         []byte
	StudentID             sql.NullInt64
	StudentUsername       sql.NullString
	StudentDetail         []byte
	StudentLearningToken  StudentLearningToken
}

func (q *Queries) GetPresencesByTeacherId(ctx context.Context, arg GetPresencesByTeacherIdParams) ([]GetPresencesByTeacherIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresencesByTeacherId,
		arg.TeacherID,
		arg.Limit,
		arg.Offset,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresencesByTeacherIdRow
	for rows.Next() {
		var i GetPresencesByTeacherIdRow
		if err := rows.Scan(
			&i.PresenceID,
			&i.Date,
			&i.UsedStudentTokenQuota,
			&i.Duration,
			&i.Class.ID,
			&i.Class.TransportFee,
			&i.Class.TeacherID,
			&i.Class.CourseID,
			&i.Class.IsDeactivated,
			&i.Course.ID,
			&i.Course.DefaultFee,
			&i.Course.DefaultDurationMinute,
			&i.Course.InstrumentID,
			&i.Course.GradeID,
			&i.Instrument.ID,
			&i.Instrument.Name,
			&i.Grade.ID,
			&i.Grade.Name,
			&i.TeacherID,
			&i.TeacherUsername,
			&i.TeacherDetail,
			&i.StudentID,
			&i.StudentUsername,
			&i.StudentDetail,
			&i.StudentLearningToken.ID,
			&i.StudentLearningToken.Quota,
			&i.StudentLearningToken.CourseFeeValue,
			&i.StudentLearningToken.TransportFeeValue,
			&i.StudentLearningToken.LastUpdatedAt,
			&i.StudentLearningToken.EnrollmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPresence = `-- name: InsertPresence :execlastid
INSERT INTO presence (
    date, used_student_token_quota, duration, class_id, teacher_id, student_id, token_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type InsertPresenceParams struct {
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	ClassID               sql.NullInt64
	TeacherID             sql.NullInt64
	StudentID             sql.NullInt64
	TokenID               int64
}

func (q *Queries) InsertPresence(ctx context.Context, arg InsertPresenceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertPresence,
		arg.Date,
		arg.UsedStudentTokenQuota,
		arg.Duration,
		arg.ClassID,
		arg.TeacherID,
		arg.StudentID,
		arg.TokenID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updatePresence = `-- name: UpdatePresence :exec
UPDATE presence
SET date = ?, used_student_token_quota = ?, duration = ?, class_id = ?, teacher_id = ?, student_id = ?, token_id = ?
WHERE id = ?
`

type UpdatePresenceParams struct {
	Date                  time.Time
	UsedStudentTokenQuota float64
	Duration              int32
	ClassID               sql.NullInt64
	TeacherID             sql.NullInt64
	StudentID             sql.NullInt64
	TokenID               int64
	ID                    int64
}

func (q *Queries) UpdatePresence(ctx context.Context, arg UpdatePresenceParams) error {
	_, err := q.db.ExecContext(ctx, updatePresence,
		arg.Date,
		arg.UsedStudentTokenQuota,
		arg.Duration,
		arg.ClassID,
		arg.TeacherID,
		arg.StudentID,
		arg.TokenID,
		arg.ID,
	)
	return err
}
